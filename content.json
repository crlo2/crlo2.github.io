{"pages":[{"title":"","text":"","link":"/categories/index.html"},{"title":"","text":"","link":"/tags/index.html"}],"posts":[{"title":"[JEKYLL과 깃허브로 블로그 만들기] 지킬 테마 복사하기","text":"1. 닉네임.github.io 레포지토리 만들기위와 같이 닉네임.github.io 이름으로 public 레포지토리를 만듭니다. 2. 사용할 템틀릿 정하기여기서(jekyll-theme){: target=”_blank”} 원하는 테마프로젝트를 선택합니다. minimal-mistakes 테마를 선택하였습니다. 3. _config.yml 파일 복사하기remote_theme : mmistakes/minimal-mistakes 추가 및 수정하기 4.index.html 복사하기1---layout: home--- 위와 같이 index.html파일을 만듭니다.","link":"/2019/05/13/tec/blog/2019-04-29-blog1/"},{"title":"[JEKYLL과 깃허브로 블로그 만들기] 포스트(Post) 쓰기","text":"1. /_posts/2019-01-01.md파일 생성하기12345678910---title: &quot;테스트 포스팅&quot;date: 2017-10-20 08:26:28 -0400categories: - testtags: - test---## 안녕하세요. 2. 완성","link":"/2019/05/13/tec/blog/2019-04-29-blog2/"},{"title":"[JEKYLL과 깃허브로 블로그 만들기] 네비게이션 메뉴 (Navigation)만들기","text":"1. /_data/navigation.yml 파일 만들기main: - title: &quot;TECHNOLOGY&quot; url: /tec/ - title: &quot;WORLD-TRIP&quot; url: /trip/ - title: &quot;OTHERS&quot; url: /posts/ 위의 내용 추가 2. 완성","link":"/2019/05/13/tec/blog/2019-04-29-blog4/"},{"title":"[JEKYLL과 깃허브로 블로그 만들기] 콜렉션(Collection)만들기","text":"1. /_config.yml파일 수정하기1234collections: trip: output: true permalink: /:collection/:path/ 위의 내용 추가 1234567891011defaults: # _trip - scope: path: &quot;&quot; type: trip values: layout: single author_profile: false share: true related: true 위의 내용 추가 2. _pages/trip-archive.md 파일 만들기12345678910---title: 여행layout: collectionpermalink: /trip/collection: tripentries_layout: gridclasses: wide--- 3._/trip/post1.md 파일 만들기123456789101112131415161718192021222324252627282930313233itle: &quot;Trip1&quot;excerpt: &quot;첫번째 여행글 입니다..&quot;header: image: /assets/images/별그림.png #teaser: assets/images/unsplash-gallery-image-1-th.jpgsidebar: - title: &quot;Role&quot; image: /assets/images/별그림.png image_alt: &quot;logo&quot; text: &quot;Designer, Front-End Developer&quot; - title: &quot;Responsibilities&quot; text: &quot;Reuters try PR stupid commenters should isn&apos;t a business model&quot;gallery: - url: /assets/images/별그림.png image_path: /assets/images/별그림.png alt: &quot;placeholder image 1&quot; - url: /assets/images/unsplash-gallery-image-2.jpg image_path: /assets/images/별그림.png alt: &quot;placeholder image 2&quot; - url: /assets/images/unsplash-gallery-image-3.jpg image_path: /assets/images/별그림.png alt: &quot;placeholder image 3&quot;categories: [아시아, 한국, korea]tags: [hot, summer]---이사진은 별그림 입니다{% include gallery caption=&quot;This is a sample gallery to go along with this case study.&quot; %}이건 마지막 글입니다.ude gallery caption=&quot;This is a sample gallery to go along with this case study.&quot; %} 4. 완성참고:https://jekyllrb-ko.github.io/docs/collections/","link":"/2019/05/13/tec/blog/2019-04-29-blog3/"},{"title":"[JEKYLL과 깃허브로 블로그 만들기] 검색 메뉴(Search)만들기","text":"1. /_config.yml 파일 수정하기search: true 위의 내용 추가 2. 완성","link":"/2019/05/13/tec/blog/2019-04-29-blog5/"},{"title":"[Hexo와 깃허브로 블로그 만들기] Hexo 테마 적용","text":"1. Hexo 테마 고르기Hexo 이쁜 테마 고르러 가기 2. icarus 테마 적용하기블로그 프로젝트 경로($ cd ~/blog/) 아래 blog/themes/icarus 폴더를 만들어 git 테마를 clone한다. 1$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 3. ~/blog/themes/icarus/_config.yml 피일에서 theme 설정을 icarus로 변경한다.1theme: icarus 4. hexo 서버 재시작 한다.123456789$ hexo s``localhost:4000에서 적용된 테마를 확인한다. ## 5. github에 배포한다.```bash$ hexo clean$ hexo d -g","link":"/2019/05/13/tec/blog/blog7/"},{"title":"[Hexo와 깃허브로 블로그 만들기] Hexo 블로그 포스트 쓰기","text":"1. ~/blog/source/_posts/ 아래에 postname.md 파일 만들기.파일을 만든 후 아래 내용을 입력한다. 1234567891011---title: &quot;[Hexo와 깃허브로 블로그 만들기] Hexo 블로그 포스트 쓰기&quot;categories: [test]tags: [test]---## Hello World! 2. jekyll 포스트 hexo로 옮기기jekyll migratorn 참고 링크 지킬 프로젝트에서 _posts/하위 폴더 다 복사 후 hexo 프로젝트 /source/_posts/에다 붙여넣기. 포스트 제목을 2019-01-01-name.md의 형식을 name.md로 변경. 포스트 내용의 Front-matter 부분을 알맞게 수정 포스트안에 이미지나 다른 첨부 내용이 있다면 같이 옮겨줌. 지킬의 /assests/images/ 폴더를 hexo의 blog/source/assets/images 로복사해줌 이미지 첨부가 맞지 않을 경우 hexo 서버가 에러가 남.","link":"/2019/05/13/tec/blog/blog8/"},{"title":"[Hexo와 깃허브로 블로그 만들기] disque로 댓글 기능 활성화 하기","text":"1. disque 회원가입disque 회원가입 하러가기 2. UserName변경Account에서 Username을 변경한다.(disque에서 유일해야함.) 3. /blog/themes/icarus/_config.yml 파일 수정123comment: type: disqus shortname: xxxxxxxx 4. post.md 파일 Front-Matter부분 수정1234# (optional) a unique id to identify the post in Disqus systemdisqusId: xxxxxxxx---Post content...","link":"/2019/05/13/tec/blog/blog9/"},{"title":"[Java의정석] CH.6 객체지향프로그래밍1","text":"1. 객체지향 언어 코드의 재사용성이 높다. 코드의 관리가 용이하다. 신뢰성이 높은 프로그래밍을 가등하게 한다. 2. 클래스와 객체 2.1 클래스와 객체의 정의와 용도클래스: 객체를 정의 해놓은것으로 객체를 생성할때 사용한다. 클래스 객체 제품설계도 제품 TV설계도 TV 붕어빵 기계 붕어빵 2.2 객체와 인스턴스클래스 —(인스턴스화)—&gt; 인스턴스(객체) 2.3 객체의 구성요소 - 속성과 기능12속성(propertiy) - 맴버변수(member variable), 특성(attribute), 필드(field), 상태(state) 기능(function)- 매서드(method), 행위(behavior), 함수(function) TV의 속성과 기능 속성 기능 크기, 길이, 높이, 색상, 볼륨, 채널 등 켜기, 끄기, 볼륨 높이기, 볼륨 낮추기, 채널 변경하기 속성-&gt; 맴버변수기능-&gt;매서드 TV 클래스1234567891011class Tv { //Tv의 속성(맴버변수) String color; boolean power; int channel; //Tv의 기능(매서드) void power(){ power=!power;} void channelUp(){++channel;} void channelDowun(){--channel;} } 2.4 인스턴스의 생성과 사용클래스 변수명; // 클래스의 객체를 참조하기 위한 참조변수를 선언한다.변수명 = new 클래스명(); // 클래스의 객체를 생성 후 , 객체의 주소를 참수변수에 저장한다. Tv t;t = new Tv(); TvTest.java1234567891011121314151617181920class Tv { //Tv의 속성(맴버변수) String color; boolean power; int channel; //Tv의 기능(매서드) void power(){ power=!power;} void channelUp(){++channel;} void channelDowun(){--channel;} }class TvTest{ public static void main(String args[]){ Tv t; // 메모리에 참조변수 t의 공간 생김 t = new Tv(); // t에 객체 주소값이 저장, 메모리 공간에 TV 클래스 인스턴스가 생김 t.channel = 7; //t에 저장된 주소에 있는 인스턴스 멤버변수 channel에 7저장 t.channelDown(); //t가 참조하는 Tv인스턴스 channelDowun매서드 호출-&gt;channel1감소} 2.5 클래스의 또 다른 정의 클래스 - 데이터와 함수의 결합 변수 - 하나의 데이터를 저장할 수 있는 공간 배열 - 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간 구조체 - 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간 클래스 - 데이터와 함수의 결합(구조체+함수) 클래스 - 사용자 정의 타입 서로 관련된 변수를 묶어서 하나의 타입으로 새로 추가1234int hour;int minute;float second;``` class Time{ int hour; int minute; float}`","link":"/2019/05/13/tec/java/2019-05-02-java1/"},{"title":"[Java의정석] CH.6 객체지향프로그래밍1","text":"3. 변수와 매서드3.1 선언위치에 따른 변수의 종류 변수의 종류 선언위치 생성시기 클래스변수 클래스 영역 클래스가 메모리에 올라갔을 때 인스턴스 변수 클래스 영역 인스턴스가 생성되었을때 지역변수 클래스 영역 이외의 영역 (메서드, 생성자, 초기화 블럭 내부) 변수 선언문이 수행되었을때 12345678class Variables{ int iv; //인스턴스 변수 static int cv; //클래스 변수(static 변수, 공유변수) void method(){ int iv; // 지역변수 }} 인스턴스 변수 클래스 영역에 선언, 인스턴스 생성때 만들어짐 클래스 변수 인스턴스 앞에 static을 붙임.한 클래스의 모든 인스턴스들이 공통적 값을 유지해야 되는 경우 사용.public을 붙이면 프로그램 내 전역에서 사용가능 지역 변수 매서드 내 선언. 메서드 내에서만 사용가능. 메서드 종료시 소멸. 3.2 클래스변수와 인스턴스 변수 123456 class Card { String kind; // 카드 무늬 - 인스턴스변수 int number; // 카드 숫자 - 인스턴스 변수 static int width = 100; // 카드 폭 - 클래스 변수 static int height = 250; //카드 높이 -클래스 변수} 인스턴스 변수는 인스턴스가 생성될 때마다 각기 다른 값을 유지,클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유해서 항상 공통된 값 가짐 3.3 메서드 하나의 메서드는 되도록 하나의 기능만 수행하도록 하는것이 좋다. 반복적으로 수행되야 하는 여러 문장을 하나의 메서드로 정의해놓으면 좋다 관련된 여러 문장을 하나의 메서드로 만들어 놓는 것이 좋다. 3.4 return 문 메서드가 정상적으로 종료되는 경우 메서드의 블럭{}내의 마지막 문장을 수행했을 때 메서드의 블럭{}내에 있는 문장을 수행중 return 문을 만났을때. return 문은 실행중인 메서드를 종료 후 호출 메서드로 되돌아감 반환값이 없는 경우 : return; 반환값이 있는 경우 : return 반환값; 3.5 메서드의 호출참조변수.메서드이름();참소변수.메서드이름(값1, 값2, ..); 3.6 JVM의 메모리 구조 Method Area(메서드영역)클래스/데이터 Call Stack(호출스택)Main Heap(힙)인스턴스 3.7 기본형 매개변수와 참조형 매개변수기본형 매개변수 - 변수의 값 읽기만 할 수 있음참조형 매개변수 - 변수의 값을 읽고 변경 할 수 있음. 3.8 재귀호출f(n) = n* f(n-1) 3.9 클래스(static 메서드)와 인스턴스메서드 클래스 설계할 때, 멤버 변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static 을 붙인다. 클래스 변수(static변수)는 인스턴스를 생성하지 않아도 사용할 수 있다. 클래스 메서드는 인스턴스 변수를 사용할 수 없다. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다. 3.10 클래스멤버와 인스턴스멤버간의 참조와 호출인스턴스 멤버가 존재할때는 클래스멤버는 항상 존재하지만,클래스맴버가 존재하는 시점에 인스턴스멤버가 존재할수도 있고 없을수도 있음.","link":"/2019/05/13/tec/java/2019-05-02-java2/"},{"title":"[Java의정석] CH6. 객체지향프로그래밍1","text":"4. 메서드 오버로딩4.1 메서드 오버로딩이란?한 클래스 내에 같은 이름의 메서드를 매개변수를 다르게 해서 여러개 정의 하는것. 4.2 오버로딩의 조건 메서드 이름이 같아야 한다. 매개변수의 개수 또는 타입이 달라야 한다. 매개변수는 같고 리턴타입이 다른 경우는 오버로딩이 성립되지 않는다. 4.3 오버로딩의 예 12345678910void println();void println(booleand x);void println(char x);void println(char[] x);void println(double x);void println(float x);void println(int x);void println(long x);void println(String x);void println(Object x); 매개 변수의 타입과 개수가 같아서 오버로딩 성립 안하는 예 12int add(int a, int b){ return a+b;}int add(int x, int y){ return x+y;} 리턴 타입만 다른 경우 오버라이딩 성립 안함 12int add(int a, int b){ return a+b;}int add(int a, int b){ return (long) a+b;} 같은 매개변수를 순서만 바꿔서 작성하면 오버로딩이지만 헷갈리는 좋지 않은 방법12int add(int a, long b){ return a+b;}int add(long a, int b){ return a+b;} 4.4 오버로딩의 장점 동일 기능의 메서드가 하나의 이름으로 정의될 수 있음 메서드 이름 절약가능 5. 생성자(Constructor)5.1 생성자란?인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드 생성자의 이름은 클래스의 이름과 같아야함 생성자는 리턴 값이 없음 new 연산자가 인스턴스를 생성하는것이지, 생성자가 인스턴스를 생성하는것은 아님 5.2 기본 생성자(default constructor)생성자를 안 만들어도 컴파일러가 기본으로 생성자 하나 만들어줌.publid 클래스이름(){}; 1234567891011121314151617181920class Data1{ int value;}class Data2{ int value; Data2(int x){ value = x; }}class ConstructorTest { public stataic void main(String[] args){ Data1 d1 = new Data1(); //컴파일 에러 발생 Data2 d2 = new Data2(); Data2 d2 = new Data2(int 1); }} 5.3 매개변수가 있는 생성자인스턴스 생성할때 초기값을 넣어 초기화 할 수 있음123456789101112class Car{ String color; String gearType; int door; Car(){} Car(String c, String g, int d){ color= c; gearType = g; door =d; }} 이렇게 사용하면 됨1Car c = new Car(&quot;white&quot;, &quot;auto&quot;, 4}; 5.4 생성자에서 다른 생성자 호출하기 - this(), this같은 클래스 내에서 생성자도 아래 조건을 만족 할 경우 서로 호출이 가능함 생성자의 이름으로 클래스 이름 대신 this를 사용한다. 한 생성자엥서 다른 생성자를 호출할 때는 반드시 첫줄에서만 호출이 가능하다. 123456789101112131415161718class Car{ String color; String gearType; int door; Car(){ this(&quot;white&quot;, &quot;auto&quot;, 4); } Car(String color){ this(color, &quot;auto&quot;, 4} Car(String color, String gearType, int door){ this.color= color; this.gearType = gearType; this.door =door; }} this - 인스턴스 자신을 가리키느 ㄴ참조변수, 인스턴스의 주소가 저장되어있다.모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재한다. this.(), this(매개변수) - 생성자, 같은 클래스의 다른 생성자를 호출 할 때 사용한다. 5.5 생성자를 이용한 인스턴스 복사 동일한 현재 상태를 갖는 인트턴스 하나 더 생성할때 생성자를 사용함. 어떤 상태인지 자세히 몰라도 똑같은 인스턴스 새로 추가 가능. 12345Car(Car c){ color= c.color; gearType = c.gearType; door =c.door; } 1234567891011121314151617181920212223class Car{ String color; String gearType; int door; Car(){ this(&quot;white&quot;, &quot;auto&quot;, 4); } Car(Car c){ color= c.color; gearType = c.gearType; door =c.door; } Car(String color){ this(color, &quot;auto&quot;, 4} Car(String color, String gearType, int door){ this.color= color; this.gearType = gearType; this.door =door; }} *** 인스턴스를 생성할 때는 아래 두가지 사항을 결정해야함 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가? 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할것인가?","link":"/2019/05/13/tec/java/2019-05-03-java3/"},{"title":"[Java의정석] CH7. 객체지향프로그래밍2","text":"1. 상속1.1 상속의 정의와 장점기존의 클래스를 재사용하여 새로운 클래스를 작성하는것 12class Parent{}class Child extends Parent{} 조상클래스 - 부모클래스, 상위클래스, 기반 클래스 자손클래스 - 자식 클래스, 하위클래스, 파생된 클래스 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다. 자손 클래스의 멤버개수는 조상 클래스보다 항상 같거나 많다. 1234567891011121314151617class Tv{ boolean power; int channel; void power(){power = !power;} void channelUp(){++chnannel;} void channelDown(){--channel;}}class CaptionTv extends Tv{ boolean caption; void displayCaption(String text){ if(caption){ system.out.println(text); } }} 1.2 클래스간의 관계 - 포함관계12345class Circle{ int x; int y; int r;} 이 클래스를 123456789class Point{ int x; int y;}class Circle{ Point point = new Point(); int r;} 이렇게 표현할 수 있다.Engine, Door 클래스를 미리 작성 후 아래와 같이 사용 가능. 1234class car{ Engine e = new Engine(); Door[] d = new Door[4];} 1.3 클래스간 관계 결정하기어떨때 상속, 어떨때 포함관계를 맺을까? 상속: ~은 ~이다(is-a) 포함 : ~은 ~을 가지고 있다(has-a) ex) 원은 점(point)이다 (X) 원은 점을 가지고 있다(O) -&gt; 포함관계 SportCar는 Car이다(0) -&gt; 상속 관계 1.4 단일 상속부모클래스를 두개 이상 상속 받을 수 없다. 1234//불가능한 경우calss TVCR extends TV, VCR{} 1234567891011121314151617181920212223242526272829303132333435class Tv{ boolean power; int channel; void power(){power = !power;} void channelUp(){++chnannel;} void channelDown(){--channel;}}class VCR{ boolean power; int counter =0; void power(){}; void play(){}; void stop(){}; void rew(){}; void ff(){};}class TVCR extends Tv{ VCR vcr = new VCR(); int counter =vcr.counter; void play(){ vcr.play(); }; void stop(){ vcr.stop(); }; void rew(){ vcr.rew(); }; void ff(){ vcr.ff(); }; 1.5 Object클래스 -모든 클래스의 조상Object는 모든 클래스의 조상이다. 1class Tv{} 이것은 따지고 보면 1class Tv extends Object{} 이것임.toString(), equals() 그냥 쓸 수 있는게 Object클래스에 정의 되어있어서 그렇다.","link":"/2019/05/13/tec/java/2019-05-03-java5/"},{"title":"[Java의정석] CH6. 객체지향프로그래밍1","text":"6. 변수의 초기화6.1 변수의 초기화변수를 선언하고 처읍으로 값을 저장하는것.가능하면 선언과 동시에 초기화 하는게 바람직. 멤버변수(클래스변수와 인스턴스 변수)와 배열의 초기화는 선택적이지만,지역변수는 반드시 초기화 후 사용해야함. 멤버변수 추기화 방법 명시적 초기화 생성자 초기화 블럭 인스턴스 초기화 블럭: 인스턴스변수를 초기화 하는데 사용 클래스 초기화 블럭: 클래스를 초기화 하는데 사용 6.2 명시적 초기화 변수 선언과 동시에 초기화 하는것 1234class Car{ int door= 4; //기본형 변수 초기화 Engine = new Engine(); // 참조형 변수 초기화} 6. 3 초기화 블럭 초기화 블럭 - 클래스변수의 복잡한 초기화에 사용 인스턴스 초기화 블럭 - 인스턴스 변수의 복잡한 초기화에 사용 1234class InitBlock{ static{/* 클래스 초기화 블럭*/} {/*인스턴스 초기화 블럭 */}} 클래스 초기화 블럭은 클래스가 메모리에 올라가 갈 때 한번만 수행.인스턴스 초기화는 인스턴스 생성될때 생성자보다 먼저 수행됨. 12345678910Car(){ System.out.println(&quot;Car인스턴스가 생성되었습니다.&quot;); color= &quot;withe&quot;; gearType=&quot;auto&quot;;}Car(String color, String gearType){ System.out.println(&quot;Car인스턴스가 생성되었습니다.&quot;); this.color= color; this.gearType=gearType;} 동일한 “Car인스턴스가 생성되었습니다.” 처리를 인스턴스 블럭으로 아래와 같이 처리 12345678910{ System.out.println(&quot;Car인스턴스가 생성되었습니다.&quot;); }Car(){ color= &quot;withe&quot;; gearType=&quot;auto&quot;;}Car(String color, String gearType){ this.color= color; this.gearType=gearType;} 6.4 멤버변수의 초기화 시기와 순서 클래스 변수 초기화 시점 - 클래스가 처음 로딩될 때 한번 초기화 인스턴스 변수의 초기화 시점 - 인스턴스가 생성될 때마다 각 인스턴스별로 초기화 이루어짐 클래스 변수 초기화 순서 : 기본값 -&gt; 명시적 초기화 -&gt; 클래스 초기화 블럭 인스턴스 변수 초기화 순서 : 기본값 -&gt; 명시적 초기화 -&gt; 인스턴스초기화 블럭 -&gt; 생성자 1234567891011class Product{ static int count =0; //생성된 인스턴스 수를 저장하기 위한 변수 int serialNo; //인스턴스 고유 번호 { ++count; serialNo = count; // Product인스턴스가 생성될 때마다 count 값을 1증가시켜 serialNo에 저장 } public product(){}}","link":"/2019/05/13/tec/java/2019-05-03-java4/"},{"title":"[Java의정석] CH7. 객체지향프로그래밍2","text":"2. 오버라이딩2.1 오버라이딩이란?조상 클래스부터 상속받은 메서드의 내용을 변경하는것12345678910111213141516class Point{ int x; int y; String getLocation(){ return &quot;x : &quot;+x+&quot;, y : &quot; + y; }|class Point3D extends Point{ int z; String getLocation(){ return &quot;x : &quot;+x+&quot;, y : &quot; + y+&quot;, z : &quot;+z; }} 2.2 오버라이딩의 조건메서드 선언부는 조상의 것과 완전 일치해야함.자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와 이름이 같아야 한다. 매개변수가 같아야 한다. 리턴 타입이 같아야 한다. 접근제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.ex) 조상클래스의 메서드의 접근 제어자가 protected라면자식클래스에서 오버라이딩 하는 메서드의 접근 제어자는 protected나 public 이어야함. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다. 조상 클래스의 메서드를 자손클래스에서 오버라이딩할 때 접근제어자를 조상클래스의 메서드보다 좁은 범위로 할 수 없다. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다. 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다. 2.3 오버로딩 VS 오버라이딩 오버로딩(overloading) : 기존에 없는 메서드를 정의하는것(new) 오버라이딩(overriding) : 상속받은 메서드의 내용을 변경하는 것(change, modify) 123456789101112class Parent{ void parentMethod(){};}class Chile extends Parent{ void parentMethod(){} // 오버라이딩; void parentMethod(int i){} //오버로딩 void childMethod(){} void childMethod(int i){} //오버로딩 void childMethod(){}// 에러 함수가 중복됨} 2.4 super자손클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수.조상클래스의 멤버와 자손클래스의 멤버가 중복 정의되서 구별해야 되지 않는 상황이면 super대신 this를 써도 됨.static 메서드(클래스 메서드)에서는 사용 할 수 없다. 12345678910111213141516171819class SuperTest{ public void static void main(String args[]){ Child c = new Child(); c.method(); }}class Parent{ int x =10;}class Child extends Parent{ int x =20; void method(){ system.out.println(&quot;x=&quot;+x); system.out.println(&quot;this.x=&quot;+this.x); system.out.println(&quot;super.x=&quot;+super.x); }} 실행 결과123x=20this.x=20;super.x=10; 2.5 super() - 조상클래스의 생성자super()는 조상클래스의 생성자를 호출하는 생성자이다.Object클래스를 제외한 모든 클래스의 생성자 첫 줄에는 생성자(같은 클래스의 다른 생성자 또는 조상의 생성자)를 호출 해야함.그렇지 않으면 컴파일러가 super(); 를 자동으로 첫줄에 삽입. 클래스 - 어떤 클래스의 인스턴스를 생성할것인가? 생성자 - 선택한 클래스의 어떤 생성자를 이용해서 인스턴스를 생성할 것인가?","link":"/2019/05/13/tec/java/2019-05-03-java6/"},{"title":"[Java의정석] CH7. 객체지향프로그래밍2","text":"3 Package와 import3.1 패키지(package)패키지란, 클래스의 묶음. 물리적으로 하나의 디렉터리임.ex) java.lang.String은 java/lang 디렉터리에 위치한 Strig 클래스이다. 하나의 소스파일에는 첫번째 문장으로 단 한번의 패키지 선언만을 허용한다. 모든 클래스는 반드시 하나의 패키지에 속해야 된다. 패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다. 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉터리다. 3.2 패키지의 선언1package 패키지명; 3.3 import 문import 문은 컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공함. 3.4 import문의 선언일반적인 소스 파일(*.java)의 구성은 다음의 순서로 되어있다. package문 import문 클래스선언 12import 패키지명.클래스명;import 패키지명.*; 4 제어자4.1 제어자란?클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여함 접근제어자 - public, protected, default, private 그외 - static, final, abstract, native, transient, synchronized, volatile, strictfp제어자는 클래스, 멤버변수, 메서드에 주로 사용됨.하나의 대상에 여러 제어자를 조합하는 것은 가능하나 접근제어자는 하나만 쓸 수 있다. 4.2 static - 클래스의, 공통적인 static 이 사용될 수 있는곳 : 멤머변수, 메서드, 초기화 블럭 *static 대상 의미 멤버변수 - 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다. - 클래스변수는 인스턴스를 생성하지 않고도 가능하다. - 클래스가 메모리에 로드될 때 생성된다. 메서드 - 인스턴스를 생성하지 않고도 호룰이 가능한 static 메서드가 된다. static 메서드 내에선 인스턴스 멤버들을 직접 사용할 수 없다. 123456789101112class StaticTest{ static int width =200; static int height = 120; static { // static 변수의 초기화 수행 } static int max(int a, int b){ return a&gt;b?a:b; }} 4.3 final - 마지막의, 변경될 수 없는final이 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수*final 대상 의미 클래스 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다. 그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없음 메서드 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다. 멤버변수/지역변수 변수 앞에 final이 붙으면 값을 변경할 수 없는 상수가 된다. 12345678final class FinalTest{ final int MAX_SIZE = 10; final void getMaxSize(){ final int LV = MAX_SIZE; return MAX_SIZE; }} 4.4 생성자를 이용한 final 멤버변수 초기화final 붙은 변수는 상수임으로 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스 변수의 경우 생성자에서 초기화 되도록 할 수 있다.각 인스턴스마다 final 이 붙은 멤버 변수가 다른 값을 갖도록 하는 것이 가능하다.123456789101112131415class Card{ final int NUMBER; final String KIND; static int width = 100; static int height =250; Card(String kind, int num){ KIND = kind; NUMBER = num; } Card(){ this(&quot;HEART&quot;,1); }} 4.5 abstract - 추상의, 미완성의미완성의 의미를 가지고 있다.메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용함. abstract가 사용될 수 있는 곳 - 클래스, 메서드 *abstract 대상 의미 클래스 클래스 내에 추상메서드가 선언되어 있음을 의미한다. 메서드 선언부만 작성하고 구현부는 작성하지 않은 추상메서드임을 알린다. 123abstract class AbstractTest{ abstract void move();} 4.6 접근제어자 멤버 또는 클래스에 사용되어 외부에서 접근하지 못하게 제한하는 역할. 접근 제어자가 사용될 수 있는곳- 클래스, 멤버변수, 메서드, 생성자 private : 같은 클래스 내에서만 접근이 가능하다. default : 같은 패키지 내에서만 접근이 가은하다. protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능하다. public : 접근 제한이 없다. 4.7 접근 제어자를 이용한 캡슐화접근 제어자 사용하는 이유: 외부로 부터 데이터를 보호하기 위해 외부에는 불필요한 내부적으로만 사용되는 부분을 감추기 위해 123456789101112131415161718192021222324252627public class Time{ private int hour; private int minute; private int second; public int getHour(){return hour;} public void setHour(int hour){ if(hour&lt;0 || hour &gt; 23){ return; } this.hour = hour; } public int getMinute(){return minute;} public void setMinute(int min){ if(min&lt;0 || hour &gt; 59){ return; } this.minute = min; } public int getSecond(){return second;} public void setSecond(int sec){ if(sec &lt;0 || sec &gt; 59){ return; } this.second = sec; }} 4.9 제어자의 조합 대상 사용가능한 제어자 클래스 public, default, final, abstract 메서드 모든 접근제어자, final, abstract, static 멤버변수 모든 접근제어자, final, static 지역변수 final 메서드에 static과 abstract를 함께 사용할 수 없다. 클래스에 abstract와 final을 동시에 사용할 수 없다. abstract메서드의 접근제어자가 private일 수 없다. 메서드에 private와 final을 같이 사용할 필요는 없다.(둘중 하나만 사용해도 충분)","link":"/2019/05/13/tec/java/2019-05-04-java7/"},{"title":"[Java의정석] CH7. 객체지향프로그래밍2","text":"5. 다형성5.1 다형성이란?여러가지 형태를 가질 수 있는 능력.조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 함.12345678910111213class Tv{ boolean power; int channel; void power(){power = !power;} void channelUp(){++channel;} void channelDown(){--channel;}}class CaptionTv extends Tv{ String text; void caption(){};} 12Tv t = new Tv();CaptionTv c = new CaptionTv(); 1Tv t = new CaptionTv(); 12CaptionTv c = new CaptionTv();Tv t = new CaptionTv(); 12//이렇게는 불가능함CaptionTv c = new Tv(); 조상 타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다. 5.2 참조변수의 형병환자손타입-&gt;조상타입(up-castion) : 형변환 생략 가능자손타입&lt;-조상타입(Down-castion) : 형변환 생략 불가 12345678910111213141516171819202122class Car{ String color; int door; void drive(){ System.out.println(\"drive, Brrr~\"); } void stop(){ System.out.println(\"stop!!\"); } }class FireEngine extends Car{ void water(){ System.out.println(\"water!!!\"); }}class Ambulance extends Car { void siren(){ System.out.println(\"siren~~!\"); }} FireEngine타입과 Ambulance타입은 서로 형변환 불가능Car 타입과 FireEngine 타입 형변환 예시123456Car car = null;FireEngine fe = new FireEngine();FireEngine fe2 = null;car = fe; //car = (Car) fe; 형변환이 생략된 형태fe2 = (FireEngine) car; //형변환 생략 불가. 아래 예제는 컴파일에러는 발생하지 않지만 실행시 에러가 발생함.12345678910111213141516171819202122232425262728293031323334class CastingTest2{ public static void main(String args[]){ Car car = new Car(); Car car2 = null; FireEngine fe = null; car.drive(); fe = (FireEngine) car; //실행시 여기서 에러 발생 fe.drive(); car2 = fe; car2.drive(); } }``` car가 Car타입의 인스턴스여서 FireEngine을 받을 수 없음.- 캐스트연산자를 사용하면 서로 상속관계에 있는 클래스 타입의 참조변수간의 형변환은 양방향으로 자유롭게 수행될 수 있다. 그러나 참조변수가 참조하고 있는 인스턴스의 자손타입으로 형변환을 하는것은 허용되지 않는다. ### 5.3 instanceof연산자 참조변수가 참조하는 인스턴스 실제타입을 확인하기 위해 instanceof연산자 사용. 주로 조건문에사용. * 값이 ull인 참조변수에 대해 instanceof연산을 하면 false나옴. ```javavoid doWork(Car c){ if(c instanceof FireEngine){ FireEngine fe = (FireEngind) c; fe.water(); } else if( c instance of Ambulance){ Ambulance a = (Ambulance) c; a.siren(); }} 123456789101112131415class InstanceOfTest{ public static void main (String args[]){ FireEngine fe = new FireEngine(); if(fe instanceof FireEngine){ System.out.println(\"FireEngine instance\"); } if( fe instanceof Car){ System.out.println(\"Car instance\"); } if( fe instanceof Object){ System.out.println(\"Object instance\"); } }} 위의 코드를 실행할 경우123FireEngine instanceCar instanceObject instance 5.4 참조변수와 인스턴스의 연결멤버변수가 조상클래스와 자손클래스에 중복으로 정의된 경우, 조상 타입의 참조변수를 사용했을 때는 조상클래스에 선언된 멤버변수가 사용되고, 지손타입의 참조변수를 사용했을 때는 자손틀래스에 선언된 멤버변수가 사용된다. 123456789101112131415161718192021222324252627class BindingTest{ public static void main(String[] args){ Parent p = new Child(); Child c = new Child(); System.out.println(\"p.x =\" + p.x); p.method(); System.out.println(\"c.x= \"+c.x); c.method(); }}class Parent { int x = 100; void method(){ System.out.println(\"Parent Method\"); }}class Child{ int x = 200; void method(){ System.out.println(\"Child Method\"); }} 실행결과1234p.x=100Child Methodc.x=200Child Method 5.5 매개변수의 다형성5.6 여러 종류의 객체를 하나의 배열로 다루기","link":"/2019/05/13/tec/java/2019-05-04-java8/"},{"title":"[Java의정석] CH7. 객체지향프로그래밍2","text":"7. 인터페이스7.1 인터페이스란?인터페이스는 일종의 추상클래스.추상클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아서추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다. 7.2 인터페이스의 작성1234interface 인터페이스이름{ public static final 타입 상수이름 = 값; public abstract 메서드이름(매개변수 목록);} 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다. 모든 메서드는 public abstract 이어야하며, 이를 생략할 수 있다. 7.3 인터페이스의 상속인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중상속이 가능하다. 12345678interface Movable{ void move(int x, int y);}interface Attactable{ void move(Unit u);}interface Fightable extends Movable, Attackable{} 7.4 인터페이스의 구현그 자체로는 인스턴스를 생성할 수 없음. 클래스에서 implements를 사용하여 구현함. 1234567891011class 클래스 이름 implements 인터페이스이름{ //인터페이스에 정의된 추상메서드 구현}class Figther implements Fightable{ public void move(int x, int y){ //기능 구현 } public void attack(Unit u){ //기능 구현 }} 구현하는 인터페이스의 메서드 중 일부만 구현하면 추상메서드로 선언되어야 함.12345abstract class Fighter implements Figtable{ public void move(int x, int y){ //기능 구현 }} 상속과 구현을 동시에 할 수 있음12345678class Figther extends Unit implements Figthable{ public void move(int x, int y){ //기능 구현 } public void attack(){ //기능 구현 }} 7.5 인터페이스를 이용한 다중상속자바에서는 다중상속을 허용하지 않아서 인터페이스로 다중상속을 할 수는 있지만 거의 하지 않는다.두개의 클래스를 상속받아야 하는 상황이라면 두 클래스중 비중이 높은걸 상속받고 나머지는 클래스 내부 멤버로 포함시키는 방법.필요한 부분을 뽑아 인터페이슬슬 만든 후 구현함. 7.6 인터페이스를 이용한 다형성인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수있고 형변환도 가능함.인터페이스 : Fightable, 클래스 : Fighter(implements Figtable)일때12Fightable f = (Fightable) new Figther();Fightable f = new Fighter(); 인터페이스는 매게변수 타입으로도 쓸 수 있음1viod attack(Figtable f){} 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야한다.여기서는 new Figther();리턴타입으로 인터페이스 타입을 지정하는것도 가능함.1234Fightable method(){ // ... return new Fighter();} 7.7 인터페이스의 장점 개발시간을 단축시킬 수 있다. 표준화가 가능하다. 서로 관계업는 클래스들에게 관계를 맺어줄 수 있다. 독립적인 프로그래밍이 가능하다. 7.8 인터페이스의 이해 클래스를 사용하는 쪽과 클래스를 제공하는 쪽이 있다. 메서드 사용하느 쪽에서는 사용하려는 메서드의 선언부만 알면된다.","link":"/2019/05/13/tec/java/2019-05-07-java10/"},{"title":"[Java의정석] CH7. 객체지향프로그래밍2","text":"6. 추상클래스6.1 추상클래스란?미완성된 설계도. 미완성 메서드(추상메서드)를 포함하고 있는 클래스.추상 클래스는 상속을 통해 자손클래스에 의해서만 완성될 수 있음.123abstract class 클래스이름{ } 6.2 추상메서드메서드 선언부와 구현부 중 선언부만 작성한것.1abstract 리턴타입 메서드이름(); 123456789101112131415161718abstract class Player{ abstract void play(int pos); abstract void stop();}class AudioPlayeer extends Player{ void play(int pos){ // 기능 구현 } void stop(){ //기능 구현 } }abstract class AbstractPlayer extends Player{ void play(int pos) { // 기능 구현 }} 6.3 추상클래스의 작성 추상 : 낱낱의 구체적 표상이나 개념에서 공통된 성질을 뽑아 이를 일반적인 개념으로 파악하는 정신 작용. 추상화 : 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업. 구체화 : 상속을 통해 클래스를 구현, 확장하는 작업 123456789101112131415161718192021222324abstract class Player{ boolean pause; int currentPos; Player(){ pause = false; currentPos = 0; } abstract void play(int pos); abstract void stop(); void play(){ play(currentPos); } void pause (){ if(pause){ pause = false; }else { pause = true; stop(); } }} 위의 Player추상클래스를 조상으로 하는 CDPlayer12345678910111213141516171819class CDPlayer extends player{ void play(int currentPos){ //기능 구현 } void stop(){ //기능 구현 } int currentTrace; void nextTrace(){ currentTrace++; } void preTrace(){ if(currentTrace&gt;1){ currentTrace--; } }} 추상메서드로 안 만들고 구현부를 빈 상태로 두어 자손 클래스에서 오버라이드해서 사용할 수 있지만추상메서드로하면 필수로 구연해야 한다. 12345678910111213141516171819class Marine{ int x,y; void move(int x, int y){} void stop(){}; void stimPack(){}}class Tank{ int x,y; void move(int x, int y){} void stop(){}; void changeMode(){}}class Dropship{ int x,y; void move(int x, int y){} void stop(){}; void load(){} void unload(){} } 위에서 공통부분을 뽑아내서 추상클래스 Unit을 만들어 다시 구현.123456789101112131415161718abstract class Unit{ int x,y; abstract void move(int x, int y); void stop(){};}class Marine extends Unit{ void move(int x, int y){} void stimPack(){}}class Tank extends Unit{ void move(int x, int y){} void changeMode(){}}class Dropship extends Unit{ void move(int x, int y){} void load(){} void unload(){} } 위와같이 구현하면 아래처럼 Unit으로 배열로 다룰 수 있음12345Unit[] grop = new Unit[4];group[0] = new Marine();group[1] = new Tank();group[2] = new Marine();group[4] = new Dropship();","link":"/2019/05/13/tec/java/2019-05-07-java9/"},{"title":"[Java의정석] CH15. 네트워킹(Networking)","text":"1.네트워킹두대 이상의 컴퓨터를 케이블로 연결하여 네트워크를 구성하는것. 1.1 클라이언트/서버(client/server)서버(server)는 서비스를 제공하는 컴퓨터, 클라이언트(client)는 서비스를 사용하는 컴퓨터.ex) 파일서버(file server), 메일서버(mail server), 어플래케이션 서버(application server) 서버기반 모델(server-based-model) P2P모델(peer-to-peer model) - 안정적인서비스 제공이 가능하다.- 공유데이터의 관리와 보안이 용이하다.- 서버구축비용과 관리비용이 든다. - 서버구축 및 운용비용을 절감할 수 있다. - 자원의 활용을 극대화 할 수 있다. - 자원의 관리가 어렵다. - 보안이 취약하다. 1.2 IP주소(IP address)IP주소는 컴퓨터(호스트, host)를 구별하는데 사용하는 고유한 값.4 byte(32bit)의 정수로 구성되어있음. a.b.c.d와 같은 형식으로 표현됨.abcd는 0~255사이의 정수이다.윈도우 콘솔에서 ifconfig를 확인하면 ip주소를 확인 할 수 있음.ex) ip주소192.168.10 .100(네트워크주소).(호스트주소) 서브넷마스크255.255.255.0 1.3 InetAddress자바에서 IP주소를 다루기 위한 클래스로 InetAddress 제공함 1.4 URL(Uniform Resource Location)URL은 인터넷에 존재하는 여러 서버들이 제공하는 자원에 접근할 수 있는 주소를 표현하기 위한것.“프로토콜://호스트명:포트번호/경로명/파이명?쿼리스트링#참조”의 형태로 이루워져있음. 프로토콜 : 자원에 접근하기 위해 서버와 통신하는데 사용되는 통신규약(http) 호스트명: 자원을 제공하는 서버의 이름(www.javahome.com) 포트번호 : 통신에 사용되는 서버의 포트번호(80) 경로명 : 접근하려는 자원이 저장된 서버상의 위치(/sample/) 파일명 : 접근하려는 자원의 이름(hello.html) 쿼리 : url에서 ?이후부분 참조 : url에서 # 이후부분 java에서 URL 클래스를 제공함 1.5 URL Connection어플리케이션과 URL간의 통신연결을 나타내는 클래스의 최상위 추상클래스. import java.net.*; import java.io.*; public class NetworkEx3{ public static void main(String[] args){ URL url = null; String address = \"http://www.javahome.com/sample/hello.html\"; String line =\"\"; try{ url = new URL(address); URLConnection conn = url.openConnection(); System.out.println(\"conn.toSTring(): \"+conn); }catch(Exception e){ e.printStackTrace(); } } } 아래코드는 해당 페이지의 내용을 읽어온다.. import java.net.*; import java.io.*; public class NetworkEx4{ public static void main(String[] args){ URL url = null; BufferedReader input = null; String address = \"http://www.javahome.com/sample/hello.html\"; String line =\"\"; try{ url = new URL(address); input = new BufferedReader(new InputStreamReader(url.openStream())); while((line= input.readline()) != null) { System.out.println(line); } input.close(); }catch(Exception e){ e.printStackTrace(); } } } 이진파일을 읽어 저장함. import java.net.*; import java.io.*; public class NetworkEx5{ public static void main(String[] args){ URL url = null; InputStream in = null; FileOutputStream out = null; String address = \"http://www.javahome.com/sample/hello.zip\"; int ch = 0; try{ url = new URL(address); in = url.openStream(); out = new FileOutputStream(\"hello.zip\"); while((ch= inlread()) != -1) { out.writy(ch); } in.close(); out.close(); }catch(Exception e){ e.printStackTrace(); } } } 2. 소켓 프로그래밍소켓을 이용한 통신프로그래밍.java.net패키지를 통해 소켓 프로그래밍을 지원함. 2.1 TCP와 UDPTCP/IP 프로토콜은 이기종 시스템간의 통신을 위한 표준 프로토콜로 프로토콜의 집합이다.TCP와 UDP모두 TCP/IP에 포함되어 있음, OSI 7계층의 전송계층에 해당하는 프로토콜이다. 항목 TCP UDP 연결방식 .연결기반- 연결 후 통신(전화기)- 1:1통신방식 .비연결기반- 연결없이 통신(소포)- 1:1, 1:n, n:n 통신방식 특징 .데이터의 경계를 구분안함.신뢰성 있는 데이터를 전송- 데이터의 전송순서가 보장됨- 데이터의 수신여부를 확인함(데이터가 손실되면 재전송)- 패킷을 관리할 필요가 없음.UDP보다 전송속도가 느림 .데이터의 경계를 구분함.신뢰성 없는 데이터 전송- 데이터의 전송순서가 바뀔 수 있음- 데이터의 수신여부를 확인안 함(데이터가 손실되어도 알 수 없음)- 패킷을 관리해 주어야 함.TCP보다 전송속도가 빠름 관련 클래스 .Scoket.ServerSocket .DatagramSocket.DatagramPacket.MulticastSocket 2.3 TCP 소켓 프로그래밍서버 프로그램과 클라이언트 프로그램간의 통신과정 단계 서버프로그램에서는 서버소켓을 사용하여 서버의 컴퓨터의 특정 포트에서 클라이언트의 연결요청을 처리할 준비를 한다. 클라이언트 프로그램은 접속할 서버의 IP주소와 포트 정보를 가지고 소켓을 생성해서 서버에 연결을 요청한다. 서버소켓은 클라이언트의 연결요청으 ㄹ받으면 서버에서 새로운 소켓을 생성해서 클라이언트의 소켓과 연결되도록 한다. 이제 클라이언트 소켓과 새로 생성된 서버의 소켓은 서버소켓과 관계없이 일대일 통신을 한다. 2.4 UDP 소켓 프로그래밍","link":"/2019/05/13/tec/java/2019-05-10-java12/"},{"title":"[Java의정석] CH11. 컬렉션프레임웍과 유용한 클래스","text":"1. 컬렉션 프레임웍(Collection Framework)1.6 Enumeration, Iterator, ListIterator1.6.1 Iterator컬렉션에 저장된 각 요소에 접근하는 기능을 가진 Iterator인터페이스를 정의해 Collection인터페이스에 Iterator를 반환하는 iterator()를 정의하고있다. public interface Iterator{ boolean hasNext(); ObjectNext(); void remove(); } public interface Collection { public Iterator(); } iterator()은 Collection 인터페이스에 구현되어있기 때문에 자손 클래스인 List와 Set에도 포함되어 있음. 메서드 설명 boolean hasNext() 읽어올 요소가 남아있는지 확인. 있으면 true, 없으면 false를 반환한다. Object next() 다음 요소를 읽어온다. next()를 호출하기 전에 hasNext()를 호출해 확인하는것이 안전하다. void remove() next()로 읽어 온 요소를 삭제. next()호출 한 다음에 remove()를 호출해야 한다. 1.6.2 Enumeration과 ListIterator Enumeration은 컬렉션 프레임웍이 만들어지기 전에 사용하는것 Iterator의 구버전. Iterator를 사용하자. ListIterator는 Iterator를 상속받아 기능을 추가한 것. 양방향으로 이동이 가능함.ArrayList나 LinkedList와 같이 List인터페이스를 구현한 컬렉션에서만 사용가능 1.7 HashSetHashSet은 Set인터페이스를 구현한 가장 대표적 컬렉션.중복된 요소를 저장하지 않음. 저장순서를 유지하지 않음.저장순서 유지하려면 LinkedHashSet을 사용하면 됨. 생성자 또는 메서드 설명 HashSet() HashSet객체를 생성한다. HashSet(Collection c) 주어진 컬렉션을 포함하는 HashSet객체를 생성한다. HashSet(int initialCapactiy) 주어진 값을 초기용량으로 하는 HashSet객체를 생성한다. HashSet(int initialCapactiy, float loadFactor) 초기용량과 load factor를 지정하는 생성자 boolean add(Object o) 새로운 객체를 저장한다 boolean addAll(Collection c) 주어진 컬렉션에 모든 객체를 추가한다. void clear() 저장된 모든 객체를 삭제한다. Object clone() HashSEt을 복제하여 반환한다. boolean contains(Object o) 지정된 객체를 포함하고 있는지 알려준다. boolean containsAll(Collection c) 주어진 컬렉션에 저장된 모든 객체들을 포함하고 있는지 알려준다. boolean isEmpty() HashSet이 비어있는지 알려준다. boolean iterator() Iterator 를 반환한다. boolean remove(Object o) 지정된 객체를 HashSet에서 삭제한다. boolean removeAll(Collection c) 주어진컬렉션에 저장된 모든 객체와 동일한 것을 HashSet에서 모두 삭제한다(차집합) boolean retainAll(Collection c) 주어진 컬렉션에 저장된 객체와 동일한 것만 남기고 삭제한다.(교집합) int size() 저장된 객체의 개수를 반환한다. Object[] toArray() 저장된 객체들을 객체배열의 형태로 변환한다. Object[] toArray(Object[] a) 저장된 객체들을 주어진 객체배열 a에 담는다. 1.8 ThreeSetThreeSet은 이진검색트리라는 자료구조의 형태로 데이터를 저장하는 컬렉션 클래스.정렬, 검색, 범위검색에 뛰어난 성능을 보인다.","link":"/2019/05/13/tec/java/2019-05-11-java14/"},{"title":"[SQL] DDL(Data Definiation Language)","text":"*자동으로 COMMIT됨(AUTO COMMIT) 1.자주쓰이는 데이터 유형CHARCTER(s) 고정길이 문자열정보 (s)만큼의 최대 고정길이를 갖고 할당된 변수값의 길이가 s보다 작을때는 공백으로 채움 ‘AA’=’AA ‘ VARCHAR2(s) 가변길이 문자열정보 s만큼 최대값 입력가능, s이하의 변수길이값입력시 변수길이만큼 바이트적용 ‘AA’ != ‘AA ‘ NUMBER-정수, 실수 등 숫자정보 NUMBER(4,2) 8은 전체자리수, 2는 소수점 자리수(1234.56)를 나타냄 DATE-날짜와 시각정보 1초돤위로 관리* 2.CREATE TABLE테이블 생성식123456CREATE TABLE TABLENAME( COLUMNNAME1 DATATYPE [DEFAULT 형식] [NULL || NOT NULL], COLUMNNAME2 DATATYPE [DEFAULT 형식] [NULL || NOT NULL], ... COLUMNNAMEN DATATYPE [DEFAULT 형식] [NULL || NOT NULL]); 테이블 생성시 주의사항 벤더에서 정의한 예약어는 쓸 수 없음 A-Z(대소문자), 0-9, _, $, # 문자만 허용됨 테이블명 칼럼명 첫 글자는 반드시 문자로 와야함 제약조건(CONSTRAINT) 사용자가 원하는 조건의 데이터남 유지하기위한, 데이터 무결성을 유지하기위해 특정 칼럼에 설정하는 제약 테이블 생성시 추가하거나 테이블 생성후 ALTER TABLE 이용해서 추가할 수 있음 123456789101112131415161718192021222324252627282930313233343536ALTER TABLE MEMBERS ADD CONSTRAINT CK_MEMBERS_POINT CHECK(POINT&lt;10) NOVALIDATE;#PRIMARY KEY(기본키)-각 행의 고유의 식별 데이터-하나의 테이블당 한개만 설정 가능-NULL 입력 불가능#UNIQUE KEY(고유키)-행데이터를 고유하게 식별하기 위한 키-테이블당 여러개 설정 가능-NULL 입력 가능--기본키 및 외래키(TABLENAME1이름의 테이블이 생성되어 있다고 가정) 입력방법1CREATE TABLE TABLENAME( COLUMNNAME1 DATATYPE [DEFAULT 형식] [NOT NULL], COLUMNNAME2 DATATYPE [DEFAULT 형식] [NOT NULL], ... COLUMNNAMEN DATATYPE [DEFAULT 형식] [NOT NULL], CONSTRAINT PK_TABLENAME_COLUMNNAME1 PRIMARY KEY(COLUMNNAME1), CONSTRAINT FK_TABLENAME_COLUMNNAME2 FOREGIN KEY(COLUMNNAME2) REFERENCES TABLENAME2(COLMNUMNAME1) );--기본키 입력방법2CREATE TABLE TABLENAME( COLUMNNAME1 DATATYPE PRIMARYKEY [NOT NULL], COLUMNNAME2 DATATYPE [DEFAULT 형식] [NOT NULL], ... COLUMNNAMEN DATATYPE [DEFAULT 형식] [NOT NULL], );--기본키 및 외래키(TABLENAME1이름의 테이블이 생성되어 있다고 가정) 입력방법3--테이블 생성 후(테이블 명 = TABLENAME)ALTER TABLE TABLENAME ADD CONSTRAINT PK_TABLENAME_COLUMNNAME1 PRIMARYKEY(COLUMNNAME1);ALTER TABLE TABLENAMEADD CONSTRAINT FK_TABLENAME_COLUMNNAME2 FOREGIN KEY(COLUMNNAME2) REFERENCES TABLENAME2(COLMNUMNAME1)--기본키 및 외래키 삭제ALTER TABLE TABLENAMEDROP CONSTRAINT PK_TABLENAME_CONLUNMNAME1;ALTER TABLE TABLENAMEDROP CONSTRAINT FK_TABLENAME_CONLUMNNAME2; NOT NULL NULL 값 입력금지 DEFAULT상태에서는 NULL 허가 NULL : 공백(“”), 숫자0이 아님, 정의되지 않은 미지의 값, 현재 데이터를 입력하지 못하는 경우NULL + 0 = NULL;NULL + ‘CHAR’ = NULL; CHECK 입력할수 있는 값의 범위를 제한 FOREIGN KEY(외래키) 관계형데이터베이스에서 테이블간의 관계를 정의하기 위해 기본키를 다른 테이블의 외래키로 복사하는 경우 외래키 생성 외래키 지정시 참조 무결성 제약옵선 선택가능 생성된 테이블 구조확인1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859DESCRIBE TABLENAME;DESC TABLENAME;``` ### SELECT 문장을 통한 테이블 생성 TABLENAME과 같은 내용의 테이블 TABLENAME1을 복사해서 생성 ```sqlCREATE TABLE TABLENAME1AS SELECT * FROM TABLENAME;``` ## 3.ALTER TABLE### ADD COLUMN- 테이블에 컬럼 추가 - 추가된 칼럼은 테이블의 마지막 컬럼이 되고 컬럼위치를 지정하는것은 불가능 ```sqlALTER TABLE TABLENAME ADD NEWCOLUMNNAME DATATYPE;``` ### DROP COLUNM - 컬럼 삭제- 데이터유무에 상관없이 삭제 가능- 한번에 하나의 칼럼만 삭제가능 - 삭제후 최소 하나이상의 칼럼이 테이블에 존재해야함- 삭제된 갈럼은 복구 불가능```sqlALTER TABLE TABLENAME DROP COLUMN COLUMNNAME1;``` ### MODIFY COLUMN- 칼럼 데이터 유형, 디폴트값(DEFAULT), NOT NULLL 제약조건 변경- 칼럼의 크기를 늘릴 수는 있지만 줄일수는 없음(기존데이터 훼손방지)- 칼럼이 NULL 값만 가지고 있으면 데이터 유형 변경가능\\- 칼럼에 행이 없거나 NULL값만 가지고 있으면 칼럼의 폭 줄이기 가능- DEFALUT값 변경시, 변경작업 이후 발생하는 행 삽입에만 영향을 미침- 칼럼에 NULL값이 없을 경우에만 NOT NULL 제약조건을 추가할 수 있음 ```sqlALTER TABLE TABLENAME MONIFY (COLUMNNAME1 DATATYPE [DEFAULT] [NOT NULL], COLUMNNAME2 DATATYPE [DEFAULT] [NOT NULL], ... COLUMNNAMEN DATATYPE [DEFAULT] [NOT NULL]); ``` ### RENAME COLUMN - 칼럼명 변경- 해당 칼럼과 관계된 제약조건이 자동으로 변경```sqlALTER TABLE TABLENAMERENAME COLUMN COLUMNNAME TO NEWCOLUMNNAME; DROP CONSTRAINT 테이블 생성시 부여했던 제약조건 삭제 12345678910111213141516171819202122232425262728293031323334353637383940414243444546ALTER TABLE TABLENAMEDROP CONSTRAINT PK_TABELNAME_COLUMNNNAME;``` ### ADD CONSTRAINT - 제약조건 추가- 외래키설정하면 참조된 테이블의 데이터 삭제가 불가능 할수도 있음 ```sqlALTER TABLE TALBENAMEADD CONSTRAINT PK_TALBENAME_COLUMNNAME PRIMARY KEY(COLUMNNAME);ALTER TABLE TABLENAMEADD CONSTRAINT FK_TABLENAME_COLUMNNAME FOREGIN KEY(COLUMNNAME) REFERENCES TABLENAME1(COLUMNNAME1); ``` ## 4. RENAEM TABLE### RENAME TABLE- 테이블 이름변경```sqlRENAME TABLE TABLENAME TO NEWTABLENAME;``` ## 5.DROP TABLE### DROPT TABLE- 테이블 삭제- CASCADE CONSTRAINT는 해당 테이블과 관계있던 참조 제약조건도 삭제한다는 뜻```sqlDROP TABLE TABLENAME [CASCADE CONSTRAINT];``` ## 6. TRUNCATE TABLE### TURNCATE TABLE- 테이블의 모든 행(데이터)삭제- DML로 분류할수도 있지만 AOUTO COMMIT특성이 있어 DDL로도 구분가능- DELETE와는 다름 - 정상적인복구가 불가능 ```sqlTURNCATE TABLE TABLENAME;","link":"/2019/05/12/tec/sql/2019-05-10-sql1/"},{"title":"[SQL] DML(DATA MANIPULATION LANGUAGE)","text":"생성된 테이블안에 데이터를 입력, 수정,삭제, 조회 하는 언어 AUTO COMMIT이 되질 않음 입력후 COMMIT하면 저장, ROLLBACK하면 SAVEPOINT나 제일 최근 COMMIT전으로 돌아감 1. INSERTINSERT 한번에 한건의 행만 입력됨 123456789101112131415161718192021--원하는 칼럼에만 데이터 입력하는 방법--칼럼명 입력하지 않은 칼럼은 NULL이나 DEFALUT값 입력됨INSERT INTO 테이블명 (칼럼명1, 칼럼명2, ... , 칼럼명N)VALUES (값1, 값2,..., 값N); --테이블에 설정된 모든 컬럼에 데이터 입력하는 방법--생성한 컬럼 순서대로 모든 값을 입력INSERT INTO 테이블명VALUES (값1, 값2, ...,값N);``` ## 2.UPDATE### UPDATE- 데이터 수정- WHERE절을 사용하지 않으면 컬럼 전체가 수정할 값으로 변경됨```sqlUPDATE 테이블명 SET 수정할값이있는컬럼명 = 수정할값 [WHERE 조건입력]; 3.DELETEDELETE 데이터삭제 WHERE절 사용하지 않으면 컬럼전체 DATA가 삭제됨 1DELETE [FROM] 테이블명 [WHERE 조건입력]; 4. SELECTSELECT 사용자가 입력한 데이터 조회 DISTINCT옵션(ALL은 DEFAULT옵션임) : 중복된 데이터가 있으면 1번만 출력 *은 WILDCARD 모든 컬럼 ALIAS 컬럼에 별명붙이기: 컬럼바로 뒤에 옴, AS 생략가능&quot;&quot;는 공백, 특수문자를 포함할경우, 대소문자 구별이 필요할 경우 사용 테이블에 있는 모든 데이터 조회(WILDCARD * 사용) 1SELECT [ALL | DISTINCT] * FROM 테이블명 테이블에 있는 원하는 컬럼에 있는 데이터 조회(+별명붙이기) 12SELECT 컬럼명1 [[AS] \"벌명1\"], 컬럼명2 [[AS] \"별명2\"], ..., 컬럼명3 [[AS] \"별명3\"] FROM 테이블명; DISTINCT옵션 1SELECT DISTINCT 칼럼명1 FROM 테이블명; 5.산술연산자 합성연산자산술연산자(NUMBER자료형에 사용)()연산자 우선순위 괄호‘* ‘‘/‘‘+’‘-‘ (CONCATENATION)합성연산자 문자와 문자의 연결 ‘||’ 사용 CONCAT(STRING1, STRING2) 칼럼과 문자 또는 다른 칼럼과 연결 문자표현식의 결과의해 새로운 칼럼 생성 산술연산자 예제 1234567SELECT 칼럼명(숫자데이터타입)-칼럼명(숫자데이터타입) AS 차이 FROM 테이블명;``` - 합성연산자 예제 ```sqlSELECT 칼럼명(STRING데이터타입) || 칼럼명(STRING데이터타입) AS 문자열합 FROM 테이블명;","link":"/2019/05/12/tec/sql/2019-05-10-sql2/"},{"title":"[SQL] TCL(TRANSACTION CONTROL LANGUAGE)","text":"1.개요 데이터베이스의 논리적 연산단위 한 개 이상의 데이터베이스 조작단위(하나 이상의 SQL구문포함) ALL OR NOTHING개념 특성 : 원자성(atomicity)-정의된 연산이 모두 성공해야함.하나라도 실패시 모두 실행하지 않음. 일관성(consistency)-실행전에 내용잘못이 없다면 실행후 데이터베이스의 내용에 잘못이 있으면 안 됨 고립성(isolation)-다른 트랜잭션의 영향을 받으면 안 됨 지속성(durability)-성공한 트랜잭션이 생신한 데이터베이스내용은 영구적으로 저장 2.COMMITCOMMIT 입력이나 수정한 자료를 저장하고싶을때 COMMIT명령을 내려 저장(COMMIT전) BUFFER에만 영향을 받았기에 데이터 변경 이전상태로 복구가능 현재 사용자가 SELECT 문장으로 결과 확인 가능 다른 사용자는 현재 사용자가 수행한 명령의 결과를 볼 수 없음 변경된 행은 잠금(LOCKING)이 설정되어 다른 사용자가 변경할 수없음(COMMIT후) 데이터 변경사항이 데이터베이스에 반영 이전데이터 영구삭제 모든 사용자가 결과 확인가능 관련된 행의 잠금이 해제, 다른사용자들이 조작가능 12-- 데이터 수정 변경 후COMMIT; AUTO COMMIT(SQL Sever방식) DDL,DML이 수행될 때마다 DBMS가 트랜잭션 컨트롤하는방식,명령이 성공적으로 수행되면 자동으로 COMMTI,실패하면 ROLLBACK됨 암시적트랜잭션(ORACLE방식) 트랜젝션 시작은 DBMS가, 끝은 사용자가 COMMIT, ROLLBACK으로 처리 명시적트랜잭션 트랜젝션 시작과 끝을 사용자가 BEGIN TRANSACTION || COMMIT TRANSACTION ,ROLLBACK TRANSACTION으로 처리 3.ROLLBACKROLLBACK 데이터 이전상태로 복구, 관련된 행에 대한 잠금이 풀림12345678910111213141516171819--데이터 수정 변경 후ROLLBACK;``` ## 4.SAVEPOINT### SAVEPOINT- ROLLBACK이 실행될 저장점을 지정- 복수저장점 정의가능- 먼저 정의된 SAVEPOINT로 롤백할 경우 이후 저장된 SAVEPOINT로 되돌릴 수 없음- DDL문장을 실행하면 자동커밋됨- DML 명령 후 DDL명령을 입력시 DML, DDL 명령모두 자동커밋- 데이터베이스 정상종료하면 자동 커밋- 어플리케이션 이상 종료는 자동 롤백```sqlSAVEPOINT SVPT1;ROLLBACT TO SVPT1;SAVE TRANSACTION SVPT2;ROLLBACK TRANSACTION SVPT2;","link":"/2019/05/12/tec/sql/2019-05-10-sql3/"},{"title":"[SQL] WHERE절","text":"1. 연산자 종류비교연산자123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167=&gt;&lt;=&gt;&gt;=``` ### SQL연산자- BETWEEN a AND b (a 이상, b이하의 값)- IN(a,b,c) (a,b,c중 하나라도 일치하는 값이 있으면 true)- LKIE &apos;비교문자열&apos; 비교문자열과 형태일치(%, _)- IS NULL NULL인 경우(=NULL은 사용할 수 없음) ### 논리연산자- AND- OR- NOT ### 부정비교연산자 - != (같지 않다)- NOT 칼럼명= a (칼럼명의 값과 a가 같지 않다)- NOT 칼럼명 &gt; a (a보다 칼럼명의 값이 크다) ### 부정SQL연산자- NOT BETWEEN a AND b (a와 b사이에 있지 않다. a,b 포함하지 않음)- NOT IN(a,b,c) (a,b,c값과 일치 하지 않음)- IS NOT NULL (NULL 값을 갖지 않음, !=NULL 사용불가) ## 2.비교연산자- STRING은 &apos;&apos;나 &quot;&quot;으로 묶어서 사용- 숫자는 &quot;&quot;,&apos;&apos;사용 안 함예제) COFFEELIST 테이블에서 브랜드가 스타벅스 커피중에 가격이 5000원 이하이고 용량이 200m이상인 커피의 브랜드, 종류, 가격, 용량순으로 조회하시오. ```sqlSELECT 브랜드, 종류, 가격 FROM COFFEELISTWHERE 브랜드 = &apos;스타벅스&apos; AND 가격 &lt;=5000 AND 용량 &gt;=200;``` ### 문자유형 비교방법 **CHAR VS CHAR**- 길이가 다른 CHAR은 작은쪽에 SPACE추가하여 비교- 서로 다른 문자가 나올때 까지 비교- 달라진 첫 문자의 값에 따라 크기 결정- BLANK 수만 다르면 서로 같은 값으로 결정**VARCHAR2 VS CHAR**- 서로다른 문자가 나올때까지 비교- 길이다 다르면 짧은것이 끝날때까지만 비교 후 길이가 긴 것이 긴것으로 결정- 길이가 같고 같은것이 없으면 같은것으로 결정- VARCHAR2는 NOT NULL까지 길이를 말함(?)**NUMVER VS 문자열**- 상수를 변수 타입과 동일하겨 변경 후 비교- 변수쪽이 CHAR 유형 타입이면 CAHR VS CHAR 적용- 변수쪽이 VARCHAR2유형 타입이면 VARCHAR2 VS CHAR 적용 ## 3. SQL 연산자- 모든 데이터 타입에 적용가능한 연산자 소개 ### IN(a,b,c) 연산자- ()안에든 조건 중 하나와 일치하면 참 예제1) COFFEELIST 테이블에서 브랜드가 스타벅스, 커피빈, 이디아인 데이터를 모두 조회하시오. ```sqlSELECT * FROM COFFEELISTWHERE 브랜드 IN(&apos;스타벅스&apos;, &apos;커피빈&apos;, &apos;이디아&apos;);``` 예제2) COFFEELIST 테이블에서 브랜드가 스타벅스이면서 가격이 5000원 이거나, 브랜드가 이디아이면서 가격이 3000원인 커피 데이터를 모두 조회 하시오. * 결과 데이터 : 스벅 5000원커피 , 이디아 3000원 커피 ```sqlSELECT * FROM COFFEELISTWHERE (브랜드, 가격) IN((&apos;스타벅스&apos;,5000),(&apos;이디아&apos;, 3000));``` 예제3) COFFEELIST 테이블에서 브랜드가 스타벅스이거나 이디아이고, 가격이 5000원이거나 3000원인 데이터를 모두 조회하시오. (예제2번과 결과가 다르다 비교하길) * 결과 데이터 : 스벅 5000원 커피, 스벅 3000원커피, 이디아 5000원 커피, 이디아 3000원 커피 ```sqlSELECT * FROM COFFEELISTWHERE 브랜드 IN(&apos;스타벅스&apos;,&apos;이디아&apos;) OR 가격 IN(5000, 3000);``` ### LIKE 연산자- %는 아무 데이터나 다 받음- _는 한표시당 한 글자만 받음 예제) COFFEELSIST테이블에서 종업원 성이 김 씨인 커피점 조회하시오. ```sqlSELECT * FROM COFFEELISTWHERE 종업원 LIKE &apos;김%&apos;;``` ### BETWEEN a AND b 연산자 예제) COFFEELIST테이블에서 가격이 3000에서 5000원인 데이터 조회. * 결과값 : 커피가격이 3000원이상 5000원이하인 커피 데이터 리스트 ```sqlSELECT * FROM COFFEELISTWHERE 가격 BETWEEN 3000 AND 5000;``` ### IS NULL 연산자- NULL 과 수치 연산은 NULL값 리턴- NULL과 비교연산은 FALSE리턴- 특정값과 비교할 수 없고 크기 비교 불가 ```sqlSELECT * FROM COFFEELISTWHERE 브랜드 = NULL;--결과값 : 선택된 레고드가 없음. (브랜드 = NULL)이 FALSE이기 때문SELECT * FROM COFFEELISTWHERE 브랜드 IS NULL;--결과값 : 브랜드칼럼에 NULL이 들어가있는 데이터 조회``` ## 4. 논리연산자### AND 해당되는 조건이 모두 참이어야 참### OR 앞뒤의 조건 중 하나라도 참이면 참### NOT뒤에오는 조건과 반대되는 결과 리턴- 연산자의 우선순위 (), NOT, AND, OR 순서이므로 ()를 적절히 사용하여 원하는 조건을 형성해야함 ## 5. 부정연산자### 논리부정연산자### 부정 SQL연산자 ## 6. ROWNUM### ROWUNUM- 임시로 부여되는 행 번호- 테이블에서 원하는 행만 가져올때 WHERE절에서 행의 개수를 제한하는 목적으로 사용```sql--1행만 가져올때SELECT * FROM COFFEELIST WHERE ROWNUM=1;SELECT * FROM COFFEELIST WHERE ROWNUM&lt;=1;SELECT * FROM COFFEELIST WHERE ROWNUM&lt;2;--2행 이상 가져올때SELECT * FROM COFFEELIST WHERE ROWNUM&lt;=3;SELECT * FROM COFFEELIST WHERE ROWNUM=3;--이건 사용불가(무조건 1행부터 데이터를 가져오기때문)--고유한 키나 인덱스로 활용가능UPDATE MY_TABLE SET COLUMN1 = ROWNNUM;","link":"/2019/05/12/tec/sql/2019-05-10-sql4/"},{"title":"[SQL] 함수","text":"1. 문자열 함수LOWER(문자열) 문자열 소문자로 변경 UPPER(문자열) 문자열 대문자로 변경ASCII(문자) 문자, 숫자를 ASCII로 변경CONCAT(문자열1, 문자열2) 문자열1과 문자열 2 합침(||와 같은 기능)SUBSTR(문자열, M [,N]) 문자열 중에 M부터 N개의 문자 리턴(N이 없으면 M부터 끝까지 리턴) LENGTH(문자열) 문자열 개수 리턴LTRIM(문자열 [,지정문자]) 문자열의 첫 문자부터 지정문자를 제거함(지정문자 생략시 “”공백 제거)RTRIM(문자열 [,지정문자]) 문자열 제일 마지막부터 지정문자를 제거함(지정문자 생략시 “”공백제거)TRIM(지정문자 FROM 문자열) 문자열의 양끝의 지정문자 제거 2. 숫자형 함수ABS(숫자) 숫자의 절대값 리턴SING(숫자) 숫자의 양수, 음수, 0을 구분(결과값 -1 OR 0 OR 1)MOD(숫자1, 숫자2) 숫자1/숫자2의 나머지 리턴CEIL(숫자) 숫자보다 크거나 같은 최소 정수리턴FLOOR(숫자) 숫자봗 작거나 같은 최대정수리턴ROUND(숫자 [,M]) 숫자를 M+1자리에서 반올림해서 리턴(M의 DEFAULT는 0)TRUNC(숫자[,M]) 숫자를 M+1자리에서 버림해서 리턴(M의 DEFAULT는0)EXP(),POWER(),SQRT(),LOG() 지수, 거듭제곱, 제곱근, 로그값 리턴 3. 날짜형 함수SYSDATE 현재 날짜, 시각 출력EXTRACT(‘YEAR’ FROM d) d 날짜에서 ‘YEAR’(년) 추출(YEAR에 MONTY, DAY 입력가능)TO_NUMBER(TO_CHAR(D,’YYYY’)) 날짜데이터에서 년도 출력TO_NUMBER(TO_CHAR(D,’MM’)) 날짜데이터에서 월도 출력TO_NUMBER(TO_CHAR(D,’DD’)) 날짜데이터에서 일 출력 4. 변환형 함수TO_NUMBER(문자열) 문자열을 숫자로 변환TO_CHAR(숫자|날짜 [,FOMAT]) 숫자나 날짜를 주어진 포맷형태로 문자열 타입으로 변환TO_DATE(문자열[,FOMAT]) 문자열을 주어진 포맷 형태로 날짜타입으로 변환 5.CASE표현함수의 성질을 가지고 있어 중첨해서 사용할 수 있음1234CASE SIMPLE_CASE_EXPRESSION 조건 ESLE 표현절END 예제) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263--예제1SELECT ENAME, CASE WHEN SAL&gt;2000 THEN SAL ELSE 2000 END REVISED_SALARYFROM EMP;--예제2)SELECT LOC, CASE LOC WHEN 'NEW YORK' THEN 'EAST' WHEN 'CHICAGO' THEN 'CENTER' ELSE 'ETC' END AS AREAFROM DEPT;``` ## 6.NULL관련함수### 연산 NULL+숫자=NULL;(사칙연산 모두 포함) NULL+문자열=NULL; ### NVL(표현식1, 표현식2)- 표현식 1 이NULL이면 표현식 2를 출력(두 표현식의 데이터 타입이 같아야함)### NULLIF(표현식1, 표현식2)- 표현식1이 표현식2와 같으면 NULL, 아니면 표현식1 출력### COALESCE(표현식1,..,표현식N)- 임의의 개수 표현식에서 NULL이 아닌 최초의 표현식 리턴,- 모든 표현식이 NULL이면 NULLD을 리턴### NULL과 공집합 테이블 안에 값이 NULL이면 NULL, 테이블 이 선택안되면 공집합 공집합을 NULL로 바꾸기 위해 적절한 함수 사용 EX)MAX()### NULLIF```sql--사원 테이블에서 MGR과 7698이 같으면 NULL, 다르면 MGR 표시하라. SELECT ENAME, EMPNO, MGR, NULLIF(MGR, 7698) NUIFFROM EMP;``` ### COALESCE```sql--사원테이블에서 커미션을 1차선택값, 급여를 2차 선택값으로 선택하되 --두 칼럼 모두 NULL이면 NULL로 표시SELECT ENAME, COMM, SAL, COALESCE(COMM, SAL) COALFROM EMP;--다른방법SELECT ENAME, COMM, SAL CASE WHEN COMM IS NOT NULL THEN COMM ELSE (CASE WHEN SAL IS NOT NULL THEN SAL ELSE NULL END) END COALFROM EMP;","link":"/2019/05/12/tec/sql/2019-05-10-sql5/"},{"title":"[SQL] GROUP BY, HAVING절","text":"1. 집계함수(AGGREGATE FUNCTION) 여러 행들의 그룹이 모여 그룹당 하나의 결과를 리턴하는 함수 GROUP BY 절은 행들을 소그룹화 함 SELECT절, HAVING절, ORDER BY 절에 사용할 수 있음. 집계함수명([DISTINCT] 칼럼이나 표현식)COUNT(*) NULL값을 포함한 행의 수 출력COUNT(표현식) 표현식의 값이 NULL값을 제외한 행의 수 출력SUM([DISTINCT] 표현식) NULL값을 제외한 합계출력AVG([DISTINCT] 표현식) NULL값을 제외한 평균출력MAX([DISTINCT] 표현식) 표현식의 최대값 출력MIN([DISTINCT] 표현식) 표현식의 최소값 출력STDDEV([D] 표현식) 표현식의 표준편차 출력VARIAN([D] 표현식) 표현식의 분산 출력 2. GROUP BY절 SQL문에서 FROM과 WHERE절 뒤에 위치, 데이터를 그룹으로 분류하여 소그룹에대한 항목별 통계정보를 얻을때 사용 12345SELECT [DISTINCT] 칼럼명 [ALIAS명]FROM 테이블명[WHERE 조건식][GROUP BY 칼럼이나 표현식][HAVING 그룹조건식]; GROUP BY, HAVING절의 특성 그룹바이로 소그룹의 기준을 정한후, SELECT 절에 집계함수를 사용 집계함수의 통계정보는 NULL값을 제외하고 수행함 WHERE절에는 집계함수 올 수 없음 HAVING절은 그룹바이절의 기준 항목이나 소그룹의 집계함수를 이용한 저건을 표시 그룹바이절에 의해 소그룹별로 만들어진 집계데이터 중, HAVING 절에 제한 조건을 두어 만족하는 내용만 출력 HAVING절은 일반적으로 GROUP BY절 뒤에 위치 1234567891011121314SELECT POSITION 포지션, AVG(HEIGHT) 평균키FROM PLAYER;--&gt;&gt;ERROR : 단일 그룹의 집계함수가 아니다라고 나옴SELECT POSITION 포지션, AVG(HEIGHT) 평균키FROM PLAYERGROUP BY POSITION 포지션;--&gt;&gt;ERROR SQL명령어가 올바르게 종료되지 않음--&gt;그룹바이에 별명ALIAS쓸 수 없음--포지션별 최대키, 최소키, 평균키 출력SELECT POSITION 포지션, MAX(HEIGHT), MIN(HEIGHT), AVG(HEIGHT)FROM PLAYERGROUP BY PISITION; 3.HAVING 절 GROUP BY후에 조건을 달고 싶을때 WHERE 대신 씀 WHERE절은 GROUP BY절 전에 오기때문에 소그룹으로 묶인후의 조건을 걸 수없음. 123456789101112131415161718SELECT POSITION 포지션, ROUND(AVG(HEIGHT),2) 평균키FROM PLAYERWHERE AVG(HIGHT) &gt;=180GROUP BY POSITION--3행오류 : 집계함수가 허가되지 않음. 그룹바이로 소그룹화 되기전에 집계함수를 사용했기때문.SELECT POSITION, ROUND(AVG(HEIGHT),2)FROM PLAYERGROUP BY POSITIONHAVING AVG(HEIGNT)&gt;=180;--이렇게써야함--예제)--최대 키가 190CM이상인 선수를 가지고 포지션별 평균 키를 출력SELECT POSICITON AVG(HEIGHT)FROM PLAYERGROUP BY POSITIONHAVING MAX(HEIGHT) &gt;=190; 4. CASE 표현을 활용한 월별 데이터 집계 모델링의 제 1정규화로 반독되는 칼럼의 경우, 구분칼럼을 두고 여러개의 레코드로 만들어진 집합을 정해진 칼럼 수만큼 확장해서 집계 보고서를 만드는 유용한 기법 예제)부서별 월별 입사자의 평균 급여를 조회, 입사후 1년마다 급여 인상이나 보너스 지급과 같은 일정이 정기적으로 잡히면 업무적으로 중요한 정보가 됨 123456789101112131415161718192021222324252627--STEPT1--개별입사정보에서 월별데이터 추출SELECT ENAME, DEPOTNO, EXTRACT(MONTH FROM HIREDATE) MONTH, SALFROM EMP;--STEPT2 월별데이터 구분SELECT ENAME, DEPTNO, CASE MONTH WHEN 1 THEN SAL END M01, CASE MONTH WHEN 2 THEN SAL END M02, CASE MONTH WHEN 3 THEN SAL END M03, CASE MONTH WHEN 4 THEN SAL END M04, CASE MONTH WHEN 5 THEN SAL END M05, CASE MONTH WHEN 6 THEN SAL END M06, CASE MONTH WHEN 7 THEN SAL END M07, CASE MONTH WHEN 8 THEN SAL END M08, CASE MONTH WHEN 9 THEN SAL END M09, CASE MONTH WHEN 10 THEN SAL END M10, CASE MONTH WHEN 11 THEN SAL END M11, CASE MONTH WHEN 12 THEN SAL END M12FROM (SELECT ENAME, DEPTNO, EXTRACT(MONTH FROM HIREDATE) MONTH, SAL FROM EMP); --STEPT3 2의구분을 부서별로 그룹화SELECT DEPTNO, AVG(CASE MONTH WHEN 1 THEN SAL END) M01, AVG(CASE MONTH WHEN 2 THEN SAL END) M02, AVG(CASE MONTH WHEN 3 THEN SAL END) M03, AVG(CASE MONTH WHEN 4 THEN SAL END) M04, AVG(CASE MONTH WHEN 5 THEN SAL END) M05, AVG(CASE MONTH WHEN 6 THEN SAL END) M06, AVG(CASE MONTH WHEN 7 THEN SAL END) M07, AVG(CASE MONTH WHEN 8 THEN SAL END) M08, AVG(CASE MONTH WHEN 9 THEN SAL END) M09, AVG(CASE MONTH WHEN 10 THEN SAL END) M10, AVG(CASE MONTH WHEN 11 THEN SAL END) M11, AVG(CASE MONTH WHEN 12 THEN SAL END) M12FROM (SELECT ENAME, DEPTNO, EXTRACT(MONTH FROM HIREDATE) MONTH, SAL FROM EMP)GROUP BY DEPTNO; 5.집계함수와 NULL처리 빈칸을 NULL이 아니라 0으로 처리하기 위해 NVL()을 사용하는 경우가 있는데, 오히려 불필요할 수 있음 행 함수는 건수가 NULL인 행을 빼고 계산함. SUM, AVG,..등 굳이 0을넣어 불필요하게 더 계산할 필요가 없음 ELSE 절 생략하면 DEFAULT 값이 NULL임 출력시 NULL이 아닌 0을 표현하고싶으면 NVL(SUM(SAL),0)이렇게 하면됨","link":"/2019/05/13/tec/sql/2019-05-10-sql6/"},{"title":"[SQL] ORDER BY 정렬","text":"1. ORDER BY 정렬12345678910111213141516171819202122232425262728293031323334353637383940414243SELECT 칼럼명 [ALIAS명]FROM 테이블명[WHERE 조건식][GROUP BY 칼럼또는 표현식][HAVING 그룹조건식][ORDER BY 칼럼이나 표현식 [ASC 또는 DESC];``` ## 2.SELECT 문장실행 순서5)SELECT 1)FROM 2)WHERE 3)GROUP BY 4)HAVING 6)ORDER BY ```sqlSELECT DNAME, LOC, DEPTNOFROM DEPTORDER BY 1,2,3 DESC;SELECT JOB FROM EMPGROUP BY JOBHAVING COUNT(*)&gt;0ORDER BY MAX(EMPNO), MAX(MGR), SUM(SAL), COUNT(DEPTNO), MAX(HIREDATE);``` ## 3. TOP N 쿼리### ROWNUM ```sql--ORDER BY가 제일 늦게 실행되기 때문에 원하는 값이 안 나옴SELECT ENAME, SAL FROM EMPWHERE ROWNUM &lt;4ORDER BY SAL;--2중쿼리 이용SELECT ENAME, SALFROM (SELECT ENAME, SAL FROM EMP ORDER BY SAL DESC)WHERE ROWNUM&lt;4;","link":"/2019/05/12/tec/sql/2019-05-10-sql7/"},{"title":"아이슬란드로","text":"운이 좋게 가족 모두 2주정도 시간이 생겨 첫 가족 해외여행 기회가 찾아왔다.오로라 보러갈래?내가던진 한마디에 엄빠가 짠듯이 케나다 옐로나이프를 찾아오셨다.오로라가 유명하지만-30도. 여행 일정을 대충 짠 다음에 비행기표를 예약했다.결제 직전 언니 일정때문에 하루만 더 생각해보자고 하고 결제를 미뤘다.하루가 지나고 여행지가 변경됐다.아이슬란드로.엄마가 생소한 여행지여서 탐탁치 않아하셨지만 어떻게 설득을했다.결론적으로 너무 잘된 결정이었던것 같다. 어딜가든 좋았겠지만가족들끼리 그렇게 하루종일 오랜시간 같이 지내는것도 오랜만이었다.","link":"/2019/05/13/trip/europ/2019-04-29-iceland1/"},{"title":"첫 오로라","text":"거의 20시간 넘게 비행기를 타고 숙소에 도착했다.첫번째 식사는 김치찌개.밤이 되었다.첫날 밤을 그냥 자고싶진 않았다.아픈 언니와 피곤한 아빠를 뒤로하고 엄마랑 그로타 등대로 향했다.기대가 크면 실망이 클까봐 기대를 꾹꾹 눌렀다.등대를 향하는 바닷가도로 위 푸른 구름이 보였다.이거 오로라 아냐?사진을 찍어보는데 흥분을 가라앉히기 힘들었다.결국 등대 가기전 불빛이 없는 공터에 차를 대고 내렸다.그냥 막 흥분이되었었다.카메라로 어떻게 찍는지 연습을 못해서…아쉽게 사진은 제대로 찍지 못하였다.눈으로 담아도 충분했다고 생각했다.(이때는ㅜㅜ)가족들이 다 오지 못한게 아쉬워 숙소로 돌아가 아빠를 모시고 왔지만아빠는 오로라 흔적만 보셨다.오로라 없는 겨울 밤하늘도 예뻤다.첫 오로라는 성공적이였다.","link":"/2019/05/13/trip/europ/2019-04-30-iceland2/"},{"title":"골든서클-굴포스","text":"굴포스 폭포로 향했다.여기는 바람이 너무 세다고 유명했던덴데우리가 갔을때는 너무나 맑고 바람이 많이 안 불었다.덕분에 폭포 소리가 정말 잘 들렸다.맑은 날씨 덕분에 무지개도 볼 수 있었다.자연속에서 이렇게 즐길 수 있는것도 행운이었다.여긴 화장실이 유료였던것 같다.","link":"/2019/05/13/trip/europ/2019-04-30-iceland4/"},{"title":"골든서클-게이시르","text":"아이슬란드 대표 관광지 골든서클 투어를 하기로 했다.첫번째 게이시르.예전에 옐로우스톤국립공원에서 간헐천을 보면서 가족들 생각이 많이났는데여기서 같이 볼수 있어서 정말 기뻤다.지구가 방구뀌는곳생각보다 냄새는 많이 안 났고 분출도 자주 있었다.나는 고프로를 들고다니며 동영상을 찍었는데아빠가 카메라 의식을 너무 많이한다.","link":"/2019/05/13/trip/europ/2019-04-30-iceland3/"},{"title":"헬라(Hella)-통나무집","text":"골든서클 투어중 싱벨리어 국립공원을 이때 못갔다.차 드라이브한게 국립공원을 다 둘러본거라고 생각했다.골든서클 투어를 마치고 근처 작은 마을인 헬라에서 묶었다.숙소 가는 길 핑크핓 하늘에 엄마가 너무 좋아하셨다.숙소뒤에 강가와 노을을 감상했다.마트에서 장을 처음 보고 저녁을 먹은 후 쉬었다.오두막집의 나무 향이 너무 좋았다.언니가 호들갑을 떨며 깨웠는데.숙소밖에서 오로라가 보였다.당장 모든 식구들을 깨워 밖으로 나갔다.아빠언니에겐 첫번째, 엄마와 나에겐 두번째 오로라였다.","link":"/2019/05/13/trip/europ/2019-04-30-iceland5/"},{"title":"스코가포스 폭포","text":"셀야란즈포스에서 조금 더 지나면 스코가포스 폭포가 나온다.조금 더 컸다.스코카포스 폭포는 폭포위로 올라가볼 수 있다.발이 아픈 언니를 빼고 가족들은 계단을 걸어 올라갔다.위에서 내려다 보는 폭포도 멋졌고 올라가니 수평선이 보였다.설산봉우리가 작은 스위스 같아 보이기도 했다.언니는 못 올라와서 아쉬웠겠다.폭포 근처라 계단에 얼음이 많아 오르고 내릴때 아주 위험했다.우리 가족은 아이젠을 신었지만 그래도 조심.특히 내려갈때 미끄러지는 사람들을 많이 봤다.나는 그냥 계단 옆길에 얼음 빙판길에 미끄럼틀을 타기로 했다.엄청 금방 안전하게 내려왔다.ㅎㅎ","link":"/2019/05/12/trip/europ/2019-04-30-iceland7/"},{"title":"[Hexo와 깃허브로 블로그 만들기] jykell에서 hexo로 블로그 이전하기","text":"hexo테마가 이쁜게 많아서 바꾸기로 함. 1. Node.js설치nodejs 설치하러 가기 2. Git 설치git 설치하러 가기 3. Hexo 설치hexo 설치하러 가기 1$ npm install -g hexo-cli 4. 블로그 시작하기git bash쉘에서 블로그 프로젝트를 구성할 디렉터리 위치에 가서 아래와 같이 실행한다. 1234$ hexo init blog$ cd blog$ npm install$ hexo server hexo server가 http://localhost:4000 으로 실행됨. 5. blog/_config.yml 파일 수정하기1234567url: http://yoursite.com deploy: type: git repo: https://github.com/crlo2/crlo2.github.io.git branch: master deploy 항목을 저렇게 수정하면 hexo가 명령어로 자동 배포 및 생성을 해준다. 6. hexo deployer 설치1$ npm insatll hexo-deployer-git --save 7. hexo 생성 및 git 레포지토리에 배포1$ hexo d -g 이렇게 배포를 해줘야만 https://clro2.github.io 주소로 접속하면 블로그 화면이 보인다.","link":"/2019/05/13/tec/blog/blog6/"},{"title":"셀애란즈포스 폭포","text":"벌써 세째날 아침.셀야란즈포스에서 멈춰섰다.링로드 1번도로에서 폭포가 멀리서 보여 찾기 쉬웠다.입장료는 없지만 주차비가 있다. 하루에 7천원정도였나.잠깐들러 사진만 찍고 가기에는 조금은 아까웠다.여름엔 폭포 뒤로 들어가볼 수도 있다고 했는데겨울이라 막혀있엇다.아쉽..맑은날에는 쌍문지개도 보인다고한다.조금은 우중충한 날씨. 춥진 않았다.","link":"/2019/05/13/trip/europ/2019-04-30-iceland6/"},{"title":"레이니스피아라","text":"폭포를 보고 검은모래 해변을 보러왔다.아빠가 무려 2천원짜리 화장실에 다녀왔다.여긴 신기하게 바닷가 특유 비릿한 냄새가 안 난다.파도와 바람이 거세어 사진찍다 사고를 당한 사람이 많다고 조심하란다.아이슬란드에서 사고가 자주 일어나니 조심히 다녀야겠다.주상절리도 보고 나름 섬 국가인데 바다에 처음 왔다.해가 지는걸 보니 이제 숙소로 돌아가야 된다.숙소잡는데 애를 좀 먹었지만 너무 좋았다.","link":"/2019/05/13/trip/europ/2019-04-30-iceland8/"},{"title":"스카이루스 게스트하우스","text":"여태껏 숙소는 다 개별룸으로 지냈는데방이 없어서 이날 하루 게스트 하우스에서 지냈다.깐깐해보이는 주인 아줌마가 계셨는데 친절했다.공용주방이 너무 작아서 두팀밖에 밥을 못 먹었다.공용화장실이지만 그래도 깨끗했다.아침에 시끄러운 공사소리가 기억에 남는다.","link":"/2019/05/13/trip/europ/2019-05-01-iceland11/"},{"title":"스노우볼 달쇼프디 게스트하우스","text":"이동시간이 길어서 어느덧 해가 져버렸다.점점 눈이 많아졌다. 깜깜해졌다.까만 세상속에 마을 불빛이 혼자 깜박였다.그 불빛이 없었으면 너무 무서웠을것 같다.잘 보이지도 않는 눈길을 조심히 달려 겨우 숙소에 도착했다.숙소빼고 주변에 건물이 세채 밖에 없었다.정말 동화속 같았다.주변이 모두 평지여서 여기서 오로라와 별을 보고싶었지만,구름이 잔뜩있었다.우리는 숙소가 너무 마음에 들어 하루를 조금 쉬어가기로 했다.오랜만에 늦잠자고, 조식을 즐기기로 했다. 다음날새벽에 깨서 혼자 산책을 나갔다.온통 눈밭에 하늘도 구름에 어스름한 안개까지 정말 스노우 볼 속에 있는 기분이었다.해가 뜨자 아쉽게 그 분위기는 사라졌지만 동화속 풍경은 여전했다.아마 가족들도 모두 이번 여행에서 가장 기억에 남는 숙소가 아니었을까.여름에 다시 오고싶은 숙소 중에 하나다.","link":"/2019/05/13/trip/europ/2019-04-30-iceland9/"},{"title":"스카프타펠-빙하 투어","text":"전날밤 스카프타펠 빙하트레킹 투어를 신청했다.두시시작이었나.눈이 와서 걱정했는데 다행이 투어시간에는 눈이 안 왔다.빙하사이를 걷는것은 굉장한 일이라고 생갔했었다.멀리서 눈에 덮인 빙하가 보였다.빙하가 아니라 눈으로 보였다.푸른 얼음 덩어리를 기대한 나는 조금 실망하기는 했다.그래도 언제 빙하를 걸어 보겠어.신기하긴했다. 제시카 가이드가 사진찍는 시간도 많이 주고설명도 친절하게 잘 해줬다.얼음동굴도 들어가봤다.얼음이 천천히 녹아 동굴이 생긴거다.겨울에만 볼 수 있는 투어여서 특별했다.위험해서 걷는 도중에 사진을 찍을 수 는 없었는데고프로를 머리에 붙이고 가서 동영상은 건질 수 있었다.노을을 내내보며 빙하 트레킹 하는것도 나쁘지는 않았다.","link":"/2019/05/13/trip/europ/2019-05-01-iceland10/"},{"title":"요쿨살론-빙하호수","text":"빙하가 떠내려온 호수인 요쿨살론에 도착했다.오로라 뷰 포인트라던데 우리는 이른 아침에 도착했다.사실 해가 짧아서 새벽도 아닌데 어스름 했다.얼음을 너무 좋아하는 내가 빙하를 먹어 볼 수 있다니!!미리 잔에 음료수를 담아가서 빙하를 넣어서 먹었다.빙하는 엄청압축되었던지 시간이 꽤 오래지나도 형태를 유지했다.여기에 정신이 팔려서 다이아몬드 비치에 못 갈뻔했다.못갔으면 너무 아쉬웠을듯.","link":"/2019/05/13/trip/europ/2019-05-01-iceland12/"},{"title":"하얀 집 - 에이일스타디르","text":"또다시 두시간 정도 달려 에이일스타디르에 도착했다.디위피보귀르에서 직선 거리는 멀지 않은데 해안선을 따라 달리느라 오래 걸렸다.오늘은 관광 코스가 없다고 그랬었는데해안선을 따라 달리는 풍경이 너무나 좋았다.하루종일 운전하는 아빠는 힘드셨을듯..바람이 세지고 어두워지니 낭떠러지 같은 해안가 도로가 굉장히 위험했다.드디어 숙소 도착.도시에 거의 다 와서 눈이 굉장히 많이 내렸다.무릎까지 순식간에 쌓였다.숙소 문이 잠겨있어 친절한 주인 아져씨가 와서 문을 열어주고 갔다.아저씨가 날씨가 안 좋아서 하루 더 지내게 되면 방을 알아봐준다고 했다.여기서 하루 더 보낼수도 있겠다 싶었다. 여태 지냈던 방중에 가장 넓고 좋았다.부얶도 크고 깨끗했고. 식자재료도 많이있었다.가장 중요했던 세탁기가 있어서 그동안 밀렸던 빨래를 몰아서 했다.","link":"/2019/05/13/trip/europ/2019-05-01-iceland15/"},{"title":"디위피보귀르-어촌마을","text":"오늘은 관광보다는 이동이 주 목적이었다.아이슬란드 두번째 도시 에이일스타디르에 도착해야했다.차를 오래 타면 힘드니까 중간 어촌도시에 내려서 쉬어갔다.기름도 넣고 네토에서 장도 봤다.네토마트는 전반적으로 보너스마트 보다 비싸다..항구도 있는 예쁜마을이었다.여기서 하루를 보냈어도 좋았을것 같다.아직 에이일스타디르까지 갈 길이 멀다.","link":"/2019/05/13/trip/europ/2019-05-01-iceland14/"},{"title":"다이아몬드 비치-빙하 해변","text":"요쿨살론 근처에 다이아몬드 비치가 있다.두군데가 있는데 아무곳이나 봐도 이쁘다.아침 햇살에 빙하가 너무 아름다웠다.왜 다이아몬드 비치라고 불리는지 너무나 이해가 갔다.바닷가에서 수달? 같은것도 봤다.오래있고 싶었지만 바닷물이 슬슬 들어오는것 같기도 하고..다음여행지가 밀려있어서 잠깐 보구 출발했다.","link":"/2019/05/13/trip/europ/2019-05-01-iceland13/"},{"title":"세이디스피외르뒤르","text":"아침에 일어나보니 눈이 많이 쌓여있었다.여행일정중 가장 많은 눈이 쌓였다고 생각했다.그래도 새로운 곳으로 떠나보기로 했다.아빠가 제일 가보고 싶어했던 세이디스피외르뒤르.월터의 현실은 상상이 된다에 나왔던 곳이다.월터가 스케이트 보드 타고 달리던 그 푸른 길을우리는 눈과 싸우며 조심히 드라이브 했다. 도시에 들어갈수록 길이 위험해지고 눈이 많이 내렸다.도착했을땐 하얀 마을이 보였다.눈이 없다면 알록달록 파스텔 톤의 이쁜 마을이었을 것 같다.시그니쳐 하늘색 교회에서 사진을 찍고.더 눈이 많이 내리기 전에 빨리 출발하기로 했다.정말 눈이 많이왔다.","link":"/2019/05/13/trip/europ/2019-05-01-iceland16/"},{"title":"미바튼","text":"테티포스에서 한바탕 고생을 한탓에 우리는 빨리 숙소에 들어가서 쉬고싶었다.1번 링로드와 완전 가까운 숙소를 예약했다.약간의 문제가 있었다.눈이 많이 쌓여서 차를 숙소까지 가져갈 수가 없었다.차는 큰도로 옆 공터에 대고, 우리가 하루동안 필요한 짐만 캐리어에 챙겨서 눈밭을 굴러 내려갔다.차가 있는 위치와 숙소는 경사가 심했고 길이 보이지 않아 호스트 아저씨가 길을 걸으며 내 주었다.우리는 길을 더 크게 내며 킬킬거리며 걸었다. 숙소는 깔끔하고 좋았다.다락방 작은 창에서는 별이 아주 잘 보였다. 고생한 우리를 위해 엄마가 닭볶음탕을 해주셨다.먹고 다들 뻗어서 쉬었다. 자다 일어니 창밖에서 오로라가 보였다.언능 식구들을 다 깨워서 이번엔 의자를 가지고 밖으로 나갔다.옆 숙소 불빛이 넘 밝아 아쉬웠지만 이렇게 별이 많은 하늘은 처음 봤다.나름 별 보는 것을 좋아해서 여러 나라에서 별을 보러 다녔는데 미바튼에서 본 하늘은 정말 최고였다.그렇게 세번째 오로라를 볼 수 있었다.실컷 또 하늘을 구경하고 야식으로 라면을 먹고 잤다.","link":"/2019/05/13/trip/europ/2019-05-04-iceland17/"},{"title":"데티포스","text":"날씨나 도로사정때문에 겨울에는 보기 힘들다는 데티포스를 가기로 했다.하필 이런 눈내리는 날씨에.아이슬란드는 겨울에 눈때문에 도로가 통제되는 일이 빈번하여도로상황을 보는 앱을 항상 보면서 다녔다.초록색은 clear 1단계.빨간색은 impassable 8단계.북쪽의 도로는 대부분 주황색, spots of ice, 하늘색 slippery 상태였다.데티포스를 향하는 길은 핑크 땡땡이.dif.driving 6단계 이었다.4륜 구동차는 다닐수 있다고 공지되어 있어 우리는 가보기로 했다.처음 들어가는 길은 신났다.모험심이 넘쳤고 스릴 있었다. 한 10분쯤 들어갔을까. 갑자기 눈이 쏟아지며 가시거리가 좁아졌다.1미터 앞도 거의 안 보이는데다가 눈이 너무 쌓여 폭포를 포기하고 돌아나오기로 했다.도로에는 우리 차 밖에 없었다.차를 돌리는데 바퀴가 헛돌았다.여행 처음으로 사고의 위험을 느꼈다.다같이 내려서 차를 밀고 겨우 돌렸다.한창 차가 눈에 빠져서 끙끙댈 때 다른 차가 들어왔다.우리 차를 보더니 곧 돌려서 나갔다.그 차가 낸 눈길을 따라 천천히 왔던 길을 되돌아 나갔다. 겨우 1번도로로 탈출할 수 있었다.빨리 숙소로 가서 쉬고 싶었다.우리의 시련은 이게 시작이었다…","link":"/2019/05/13/trip/europ/2019-05-01-iceland17/"},{"title":"미바튼","text":"전날 눈과 사투를 너무 많이 벌여서 빨리 숙소로","link":"/2019/05/13/trip/europ/2019-05-04-iceland18/"},{"title":"[Java의정석] CH11. 컬렉션프레임웍과 유용한 클래스","text":"1. 컬렉션 프레임웍(Collection Framework)데이터군을 저장하는 클래스들을 표준화 한 설계. 1.1 컬렉션프레임웍의 핵심 인터페이스 - List, Set, Map 인터페이스 특징 List 순서가 있는 데이터의 집합. 데이터의 중복을 허용한다. 예) 대기자 명단 구현클래스: ArrayList, LinkedList, Stack, Vector 등 Set 순서를 유지하지 않는 데이터의 집합. 데이터의 중복을 허용하지 않는다. 예) 양의 정수집합, 소수의 집합 구현클래스 : HashSet, ThreeSet 등 Map 키(key)와 값(value)의 쌍(pair)으로 이루어진 데이터의 집합 순서는 유지되지 않으며, 키는 중복을 허용하지 않고 값은 중복을 허용한다.예) 우편번호, 지역번호(전화번호)구현클래스: HashMap, ThreeMap, Hashtable, Properties 등 1.1.1 Collection 인터페이스 메서드 설명 boolean add(Object o)boolean addAll(Collection o) 지정된 객체 또는 컬렉션이 객체들을 Collection 에 추가한다. void clear() Collection 의 객체를 모두 삭제한다. boolean contains(Object o)boolean containsAll(Collection c) 지정된 객체 또는 Collection의 객체들이 Collection에 포함되어 있는지 확인한다. boolean equals(Object o) 동일한 Collection인지 비교한다. int hashCode() Collection의 hash code를 반환한다. boolean isEmpty() Collection이 비어있는지 확인한다. Iterator iterator() Collection의 Iterator를 얻어서 반환한다 boolean remove(Object o) 지정된 객체를 삭제한다 boolean removeAll(Collection c) 지정된 Collection에 포함된 객체들을 삭제한다. boolean retainAll(Collection c) 지정된 Collection에 포함된 객체만을 남기고 다른 객체들은 Collection에서 삭제한다. 이 작업으로 인해 Collection에 변화가 있으면 true없으면 false를 반환한다. int size() Collection에 저장된 객체의 개수를 반환한다. Object[] toArray() Collection에 저장된 객체를 객체배열(Object[])로 반환한다. Object[] toArray(Object[] a) 지정된 배열에 Collectiom의 객체를 저장해서 반환한다. 1.1.2 List인터페이스| 메서드 | 설명 || void add(int index, Object element) addAll(int index, Collection c) | 지정된 위치에 객체 똔ㄴ 컬렉션에 포함된 객체들을 추가한다. || Object get(int index) | 지정된 위치에 있는 객체를 반환한다. || int indexOf(Object o) | 지정된 객체의 위치를 반환한다.(List의 첫번째 요소부터 순방향으로 찾는다.) || int lastIndexOf(Object o) | 지정된 객체의 위치를 반환한다. (List의 마지막 요소부터 역방향으로 찾는다.) || ListIterator listIterator() ListIterator listIterator(int index) | List의 객체에 접근할 수 있는 ListIterator를 반환한다. || Object remove(int index) | 지정된 위치에 있는 객체를 삭제하고 삭제된 객체를 반환한다. || Object set(int index, Object element) | 지졷왼 위치에 객체를 저장한다. || List subList(int fromIndex, int toIndex) | 지정된 범위에 있는 객체를 반환한다. | 1.1.3 Set인터페이스중복을 허용하지 않고 저장순서가 유지되지 않는 컬렉션 클래스를 구현하는데 사용됨. HashSet, ThreeSet등이 있음. 1.1.4 Map인터페이스 메서드 설명 void clear() Map의모든 객체를 삭제한다 boolean containsKey(Object Key) 지정된 key 객체와 일치하는 Map의 key 객체가 있는지 확인한다. boolean containsValue() 지정된 value객체와 일치하는 Map의 value객체가 있는지 확인한다. set entrySet() Map에 저장되어있는 key-value쌍을 Map.Entry타입의 객체로 저장한 Set으로 반환한다. boolean equals(Object o) 동일한 Map인지 비교한다 Object get(Object key) 지정한 key 객체에 대응하는 value 객체를 찾아서 반환한다. int hashCode() 해시코드를 반환한다. boolean isEmpty() Map이 비어있는지 확인한다. Set keySet() Map에 저장된 모든 key 객체를 반환한다. Object put(Object key, Object value Map에 value객체를 key객체에 연결하여 저장한다. void putAll(Map t) 지정한 Map의 모든 key-value쌍을 추가한다. Object remove(Object key) 지정한 key객체와 일치하는 key-value 객체를 삭제한다 int size() Map에 저장된 key-value쌍의 개수를 반환한다. Collection values() Map에 저장된 모든 value객체를 반환한다. 1.1.5 Map.Entry 인터페이스1.2 동기화(Synchronization)Collections클래스에 아래와 같은 동기화 메서드 제공함. 필요할때 사용가능. static Collection synchronizedCollection(Collection c) static List synchronizedList(List list) static Map synchronizedMap (Map m) static Set synchronizedSet(Set s) static SortedMap synchronizedSortedMap(SortedMap m) static SortedSet synchronizedSortedSet(SortedSet s) 위 메서드를 아래와 같이 사용가능함. List list = Collections.synchronizedList(New ArrayList(...)); 1.3 Vector와 ArrayList 공통점 차이점 - List인터페이스를 구현한다.저장순서가 유지되고 중복을 허용한다.- 데이터의 저장공간으로 배열을 사용한다. - Vector는 멀티쓰레드에 대한 동기화가 되어있으나 ArrayList는 그렇지 않다. Deep Copy vs Shallow Copy Shallow : 단순히 참조만 복사하는것, 원본 객체에 영향을 받는다.Deep : 원본과 같은 데이터를 저장하고 있는 새로운 객체나 배열을 생성하는것. 원본 객체에 영향을 받지 않음 1.4 LinkedList배열의 단점 크기를 변경할 수 없다. 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다. LinkedList는 불연속적으로 존재하는 데이터를 서로 연결한것.링크드리스트의 각 요소(node)들은 자신과 연결된 다음 요소에 대한 참조(주소값)과 데이터로 구성됨. class Node{ Node next; // 다음요소의 주소를 저장 Object obj; // 데이터를 저장 } 이동방향이 단방향이어서 다음 요소에 대한 접근은 쉽지만 이전요소에 대한 접근은 어렵다.이 단점을 보완한것이 더블링크드리스트(이중 연렬리스트)링크드리스트에 참조변수를 하나 추가해서 이전 요소에 대한 참조가 가능하게 한것. class Node{ Node next; //다음 요소의 주소를 저장 Node previous; //이전 요소의 주소를 저장 Object obj; // 데이터를 저장 } 더블써큘러링크드 리스트두 있음. 순차적으로 추가/삭제하는 경우에는 ArrayList가 LinkedList보다 빠르다. 중간데이터를 추가/삭제하는 경우에는 LinkedList 가 ArrayList보다 빠르다. 데이터의 개수가 변하지 않는 경우는 ArrayList, 데이터 개수의 변경이 잦다면 LinkedList를 사용하는것이 낫다. 두가지 혼합 방법 : 처음작업전 데이터는 ArrayList에 저장, 작업할때는 LinkenList로 옮겨서 사용 ArrayList al = new ArrayList(1000000); for(int i = 0; i &lt; 1000000; i++) { al.add(i+\"\"); } LinkedList ll = new LinkedList(al); for(int i = 0; i &lt; 1000; i++) { al.add(500, \"X\"); } 1.5 Stack과 Queue Stack은 마지막에 저장된 데이터를 가장 먼저 꺼냄 LIFO Queue는 처음에 저장한 데이터를 가장 먼저 꺼냄 FIFO Queue는 ArrayList보다 LinkedList로 구현하는것이 더 적합 Stack 메서드 설명 boolean empty() Stack이 비어있는지 알려준다 Object peek() Stack의 맨 위에 저장된 객체를 반환한다. 꺼내지는 않는다. 비어있으면 null을 반환한다. Object pop() Stack의 맨 위에 저장된 객체를 꺼낸다. Object push(Object item) Stack에 객체를 저장한다. int search(Object o) Stack에서 주어진 객체를 찾아서 그 위치를 반환한다.1부터 시작함 Queue 메서드 설명 Object element() 삭제없이 저장된 요소를 읽어온다. peek와 다른점은 queue가 비었을때 Exception을 발생시킴 boolean offer(Object o) Queue에 객체를 저장한다. 성공하면 true, 실패하면 false를 반환한다. Object peek() 삭제없이 읽어온다. Queue가 비었을때는 null을 반환한다. Object pool() Queue에서 꺼내온다. 비어있을때는 null을 반환한다. Object remove() Queue에서 꺼내온다. 비어있으면 에외를 발생시킨다. 스택의 활용 예 : 수식계산. 수식괄호검사, 워드프로세서의 undo/redo, 웹브라우저 앞으로 뒤로 큐의 활용 예 : 최근사용문서, 인쇄작업대기목록, 버퍼","link":"/2019/05/12/tec/java/2019-05-11-java13/"},{"title":"[Java의정석] CH12. 쓰레드","text":"1. 프로세스와 쓰레드프로세스(process)는 간단하게 말하면 실행중인 프로그램이다.프로그램 –실행–&gt; 프로세스프로세스는 데이터, 메모리등의 자원과 쓰레드로 구성되어있음.프로세스의 자원을 이용해서 실제 작업을 수행하는 것.모든 프로세스는 최소 하나 이상의 쓰레드가 존재. 둘 이상이면 멀티쓰레드 프로세스라한다. 멀티쓰레딩의 장점 CPU의 사용률을 향상시킴. 자원을 보다 효울적으로 사용할 수 있음. 사용자에 대한 응답성이 향상됨. 작업이 분리되어 코드가 간결해짐. 동기화(synhronization), 교착상태(deadlock)등을 고려해서 신중히 프로그래밍 해야함. 2. 쓰레드의 구현과 실행구현 방법 Thread클래스 상속 12345class MyThread extends Thread{ public void run(){ //Thread의 run()함수를 오버라이딩. }} Runnable인터페이스 구현(일반적인 방법) 12345class MyThread implements Runnable{ public void run(){ //추상메서드 run()을 구현 }} 123456789101112131415161718192021222324class ThreadEx1{ public static void main(String[] args){ ThreadEx1_1 t1 = new ThreadEx1_1(); Runnable r = new ThreadEx1_2(); Thread t2 = new Thread(r); }}class ThreadEx1_1 extends Thread{ public void run(){ for(int i = 0; i &lt; 5; i++) { System.out.println(getName()); } }}class ThreadEx1_2 implements Runnable{ public void run(){ for(int i = 0; i &lt; 5; i++) { System.out.println(Thread.currentThread().getName()); } }} 쓰레드 생성 후 start()를 호출해야 작업을 시작함.한번 사용한 쓰레드는 다시 재사용할 수 없다. 하나의 쓰레드에 한번의 start()만 호출 될 수 있음. 1234567891011ThreadEx1_1 t1 = new ThreadEx_1();t1.start();t.start();//이건 불가능``` ```javaThreadEx1_1 t1 = new ThreadEx1_1();t1.start();t1 = new ThreadEx1_1();t.start();//이건 가능 3. start()와 run() run()을 호출하는 것은 생성된 쓰레드를 실행하는 것이 아니라 단순히 클래스에속한 메서드를 하나 호출하는것. call stack run main start()을 호출하는 것은 새로운 쓰레드가 작업을 실행하는데 필요한 호출스택을 생성한 후 run()을 호출해서 생성된 호출스택에 run()이 저장되게 한다.모든 쓰레드는 독립적인 작업을 수행하기 위해 자신만의 호출스택을 필요로 하기 때문에 새로운 쓰레드를 생성하고 실행시킬때마다 새로운 호출스택이 생성되고 쓰레드가 종료되면 작업에 사용된 호출스택은 소멸된다. main메서드에서 쓰레드의 start메서드를 호출한다. start메서드는 쓰레드가 작업을 수행하는데 사용될 새로운 호출 스택을 생성한다. 생성된 호출스택에 run 메서드를 호출해서 쓰레드가 작업을 수행하도록 한다. 이제는 호츨스택이 2개이기때문에 스케줄러가 정한 순서에 으해 번갈아 가면서 실행된다. 실행중인 쓰레드가 하나도 없을때 프로그램은 종료된다. 4. 싱글쓰레드와 멀티쓰레드두개의 작업을 하나의 쓰레드로 하면 한 작업 끝난 후 다른 작업 끝.두개의 작업을 두개의 쓰레드로 하면 짧은시간동안 쓰레드 2개가 번갈아 가면서 작업을 수행해서 동시에 두 작업이 처리되는것과 같다고 느낌.CPU만 사용하는 계산 작업이면 멀티쓰레드가 전환하는 시간때문에 오히려 느림.CPU외 자원을 사용하는 경우 싱글쓰레드 프로세스 보다 멀티쓰레드프로세스가 더 효율적임.ex)외부기기에서 입출력 받는 경우123456789101112131415import javax.swing.JOptionPane;class ThreadEx6{ public static void main(String[] args) throws Exception{ String input = JOptionPanel.showInputDialog(\"아무 값이나 입력하세요.\"); System.out.println(\"입력하신 값은 \"+input+\"입니다.\"); for(int i = 10; i &gt; 0 ; i--) { System.out.println(i); try{ Thread.sleep(1000); }catch(Exception e){} } }} 위의 예는 입력을 받은 후 출력하기 때문에 사용자가 입력하는 동안에는 출력 작업이 일어나지 않는다.123456789101112131415161718192021222324import javax.swing.JOptionPane;class ThreadEx7{ public static void main(String[] args) throws Exception{ ThreadEx7_1 th1 = new ThreadEx7_1(); th1.start(); String input = JOptionPanel.showInputDialog(\"아무 값이나 입력하세요.\"); System.out.println(\"입력하신 값은 \"+input+\"입니다.\"); }}class ThreadEx7_1 extends Thread{ public void run(){ for(int i = 10; i &gt; 0 ; i--) { System.out.println(i); try{ Thread.sleep(1000); }catch(Exception e){} } }} 위의 코드는 입력받는 동안 출력되고 입력된 값이 출력되고 또 출력이 된다. 5. 쓰레드의 우선순위쓰레드에 우선순위(priority)의 멤버변수가 있다.우선순위의 범위는 1~10이고 숫자가 높을수록 더 우선순위가 높다.우선순위의 값은 상대적이다. 1,2와 8,9의 결과 값이 같다.우선순위는 쓰레드생성한 쓰레드로부터 상속받는다.main 메서드를 수행하는 쓰레드의 우선순위는 5.파일 다운로드와 채팅기능 중 채팅에 더 우선순위를 높여야 한다.123456void setPripority(int new Priority);int getPriority();public static final int MAX_PRIORITY =10;public static final int MIN_PRIORITY =1;public static final int NORM_PRIORITY = 5; 12345678910111213141516171819202122232425262728class ThreadEx9{ public static void main(String[] args) throws Exception{ ThreadEx9_1 th1 = new ThreadEx9_1(); ThreadEx9_2 th2 = new ThreadEx9_2(); th2.setPriority(7); System.out.println(\"입력하신 값은 \"+input+\"입니다.\"); th1.start(); th2.start(); }}class ThreadEx9_1{ public void run(){ for(int i = 0; i &lt; 300 ; i++) { System.out.println(\"-\"); for(int j = 0; j &lt; 1000000 ; j++) {} } }}class ThreadEx9_2{ public void run(){ for(int i = 0; i &lt; 300 ; i++) { System.out.println(\"|\"); for(int j = 0; j &lt; 1000000 ; j++) {} } }} 위 결과는 |가 먼저 끝나고, - 이 완료된다. 6. 쓰레드 그룹(thread group)서로 관련된 쓰레드를 그룹으로 다루기 위한것.폴더를 생성해서 관련된 파일을 묶어 관리하는것처럼 쓰레드도 그룹으로 묶어서 관리.쓰레드를 쓰레드 그룹에 포함시키려면 Thread생성자를 이용해야함12Thread(ThreadGroup group, String name)Thread(ThreadGroup gorup, Runnable target) 7. 데몬쓰레드(deamon thread)데몬쓰레드는 일반 쓰레드의 작업을 돕는 보조역할.일반쓰레드 작업이끝나면 데몬 쓰레드는 강제종료됨.ex) 가비지컬렉터, 위드프로세서 자동저장, 화면자동갱신무한루프와 조건문을 이용해서 실행 후 대기하고 있다가 특정 조건이 되면 작업 수행하고 다시 대기. 8. 쓰레드의 실행제어쓰레드 프로그램이 어렵게 느껴지는 건 동기화와 스케줄링때문임. 쓰레드 스케쥴링과 관련된 메서드 생성자/메서드 설명 void interupt() sleep()이나 join()에 의해 일시정지상태인 쓰레드를 실행대기상태로 만든다. 해당 쓰레드에서는 interuptedExcetption이 발생함으로써 일시정지상태를 벗어나게 된다. void join()void join(long millis) void join(long millis, int nanos) 지정된 시간동안 쓰레드가 실행되도록한다. 지정된 시간이 자나거나 작업이 종료되면 join()을 호출한 쓰레드로 다시 돌아와 실행을 계속한다. void resume() supend()에 의해 일시정지상태에 있는 쓰레드를 실행대기 상태로 만든다. static void sleep(long millis)static void sleep(long millis, int nanos) 지정된 시간( 천분의 일초 단위) 동안 쓰레드를 일시정지 시킨다. 지정한 시간이 지나고 나면 자동적으로 다시 실행대기가 된다. void stop() 쓰레드를 즉시 종료시킨다. 교착상태(dead-lock)에 빠지기 쉽기 때문에 deprecated되었다. void suspend() 쓰레드를 일시정지시킨다. resume()을 호출하면 다시 실행대기상태가 된다. satic void yield() 실행중에 다른 쓰레드에게 양보하고 실행대기상태가 된다. 쓰레드의 상태 상태 설명 NEW 쓰레드가 생성되고 아직 start()가 호출되지 않은 상태 RUNNABLE 실행 중 또는 실행 가능한 상태 BLOCKED 동기화 블럭에 의해서 일시정지된 상태(Lock이 풀릴때까지 기다리는 상태) WATING, TIMED_WATING 쓰레드의 작업이 종료되지는 않았지만 실행가능하지 않은 일시정지 상태. TIMED_WATEING은 일시정지시간이 지정된 경우를 의미한다. TERMINATED 쓰레드의 작업이 종료된 상태 쓰레드 생성하고 start()을 호출하면 실행대기열에 저장. 순서를 기다림. Quequ와같은 구조로 먼저 실행대기열에 들어온 쓰레드가 먼저 실행됨. 실행대기상태이다가 자기 차례가 오면 실행상태가 됨. 주어진 실행시간이 다되거나 yeild()를 만나면 다시 실행대기 상태가 되고 다음 차례의 쓰레드가 실행상태가 됨. 실행중 suspend(), sleep(), wait(), join(), I/O block에 의해 일시정지상태가 딜 수 있음. 지정된 일시정지 시간이 지나거나 notify(), reusme(), interrup()가 호출되면 일시정지 상태를 벗어나 다시 실행대기열에 들어가 순서를 기다림. 실행을 모두 마치거나 stop()이 호출되면 쓰레드는 소멸됨. join()을 사용한 예시 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class ThreadEx13{ static long startTime=0; public static void main(String[] args) throws Exception{ ThreadEx13_1 th1 = new ThreadEx13_1(); ThreadEx13_2 th2 = new ThreadEx13_2(); th1.start(); th2.start(); startTime = System.currentTimeMillis(); try{ th1.join();//th1의 작업이 끝날때까지 기다린다. th2.join();//th2의 작업이 끝날때까지 기다린다. }catch (InterruptedException e){} System.out.println(\"소요시간:\" + (System.currentTimeMillis()- ThreadEx13.startTime)); }}class ThreadEx13_1{ public void run(){ for(int i = 0; i &lt; 300 ; i++) { System.out.println(\"-\"); } }//run()}class ThreadEx13_2{ public void run(){ for(int i = 0; i &lt; 300 ; i++) { System.out.println(\"|\"); } } //run()}``` join()을 사용하지 않으면 main 쓰레드는 바로 종료되지만, join()을 사용해서 th1과 th2의 작업이 마칠때까지 main쓰레드가 기다림 - 쓰레드가 순차적으로 실행되어야 할때 사용하는 예제. ```javaclass ThreadEx14{ static long startTime=0; public static void main(String[] args) throws Exception{ ThreadEx14_1 th1 = new ThreadEx14_1(); ThreadEx14_2 th2 = new ThreadEx14_2(); th1.start(); try{ th1.join(); }catch (InterruptedException e){} th2.start(); }}class ThreadEx14_1{ public void run(){ for(int i = 0; i &lt; 300 ; i++) { System.out.println(\"-\"); } }//run()}class ThreadEx14_2{ public void run(){ for(int i = 0; i &lt; 300 ; i++) { System.out.println(\"|\"); } }} 아래 코드는 th1, th2, Main쓰레드 순으로 종료됨 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class ThreadEx15{ static long startTime=0; public static void main(String[] args) throws Exception{ ThreadEx15_1 th1 = new ThreadEx15_1(); ThreadEx15_2 th2 = new ThreadEx15_2(); th1.start(); th2.start(); try{ th1.sleep(); }catch (InterruptedException e){} System.out.println(\"&lt;&lt;main종료&gt;&gt;\"); }}class ThreadEx15_1{ public void run(){ for(int i = 0; i &lt; 300 ; i++) { System.out.println(\"-\"); } System.out.println(\"&lt;&lt;TH1종료&gt;&gt;\"); }//run()}class ThreadEx15_2{ public void run(){ for(int i = 0; i &lt; 300 ; i++) { System.out.println(\"|\"); } System.out.println(\"&lt;&lt;TH2종료&gt;&gt;\"); } //run()}``` 왜 th1이 sleep()으로 잠들어있어도 가장 먼저 종료될까? sleep()이 항상 현재 실행중인 쓰레드에 대해 작동해서 th1.sleep()호출해도 main메서드를 실행하는 main쓰레드가 영향받는다. static으로 선언되어 있어서 참조변수로 sleep()을 호출하기 보다는 Thread.sleep()이렇게 호츨해야 함.## 9. 쓰레드의 동기화 멀티쓰레드는 여러 쓰레드가 같은 프로세스내의 자원을 공유하기 때문에 데이터가 원래 의도했더것과는 다르게 변경 될 수 있음. ### 9.1 synchorized를 이용한 동기화 공유 데이터에 lock을 걸어 먼저 작업중이던 쓰레드가 작업을 완전히 마칠때까지는 다른 쓰레드에게 제어권이 넘어가도 데이터가 변경되지 않도록 보호함. - synchronized 사용방법 두가지. 가능하면 메서드에 synchronized를 사용하는 메서드 단위 동기화를 권장함. ```java// 1. 특정한 객체에 lock을 걸고자 할때 sysnchronized(객체의 참조변수){ }// 2. 메서드에 lock을 걸고자 할때 public void synchronized void calcSum(){ } synchronized를 이용해서 객체를 동기화 하면 쓰레드가 교착상태에 빠질 수 있다.교착상태란 구 쓰레드가 lock이 된 상태로 서로 lock가 풀리기를 무한정 기다리게 되는상황. 1234567891011121314151617181920212223class ThreadEx21 { public static void main(String[] args){ RunnbaleImpl r = new RunnableImpl(); Thread th1 = new Thread(r); Thread th2 = new Thread(r); th1.start(); th2.start(); }}class RunnableTmpl implements Runnable { int iv = 0; public void run(){ int lv = 0; String name = Thread.currentThread().getName(); while(lv&lt;3){ System.out.println(name+\"Local var: \"+ ++lv); System.out.println(name+\"Instance var: \"+ ++iv); System.out.println(); } }} 실행결과1234567891011121314151617Thread-0 Local var: 1Thread-0 Instance var: 1 Thread-0 Local var: 2Thread-0 Instance var: 2 Thread-0 Local var: 3Thread-0 Instance var: 3 Thread-0 Local var: 1Thread-0 Instance var: 4 Thread-0 Local var: 2Thread-0 Instance var: 5 Thread-0 Local var: 3Thread-0 Instance var: 6 여기서 인스턴스변수 iv는 main, th1, th2 쓰레드 모두 접근이 가능함.(쓰레드간의 변수 공유) lv는 지역변수라 각 쓰레드 스택내에서 생성되어 공유되지 않는다. 다음은 동기화가 잘 되지 않아 데이터 값이 변형된 예제.123456789101112131415161718192021222324252627282930class ThreadEx24{ public static void main(String[] args){ RunnbaleImpl r = new RunnableImpl(); Thread th1 = new Thread(r); Thread th2 = new Thread(r); th1.start(); th2.start(); }}class Account{ int balance =1000; public void withdraw (int money){ if(balance&gt;=money){ try{ Thread.sleep(1000);} catch(Exception e){} balance -=money; } }//withdraw}class RunnableEx24 implements Runnable{ Account acc = new Account(); public void run(){ while(acc.balance &gt; 0){ //100, 200, 300중의 한 값을 임의로 선택해서 출금 int money = (int)(Math.random()*3+1)*100; acc.withdraw(money); System.out.println(\"balance:\"+acc.balance); } }//run()} 실행 결과123456789101112131415161718192021222324252627282930balance:700balance:400balance:200balance:0balance:-100``` 잔고(balance)가 임의의 출금금액(money)보다 클 경우에만 출금하도록 되어있는데 잔고에 -100이 나왔음. if조건문 통과하고 출금직전에 다른쓰레드가 끼어들어서 먼저 출금했기때문이다. if문과 출금하는 기능은 하나로 synchronized되어야 한다. ```javapublic synchronized void withdraw (int money){ if(balance&gt;=money){ try{ Thread.sleep(1000);} catch(Exception e){} balance -=money; }}//withdraw``` ```javapublic void withdraw (int money){ synchronized(this){ if(balance&gt;=money){ try{ Thread.sleep(1000);} catch(Exception e){} balance -=money; } }}//withdraw 9.2 wait()과 notify() 쓰레드를 동기화 할때 효율을 높이기 위해 사용할 수 있다. 한쓰레드가 lock걸려 다른 쓰레드는 lock이 풀릴때까지 기다려야 되는 상황이 있음. 쓰레드에 lock을 걸는것 대신에 wait()을 호출해서 다른 쓰레드에 제어권을 넘겨주고 대기상태로 기다리다가 다른쓰레드에 의해 notify()가 호출되면 다시 실행상태가 되도록 함 wait()과 notify()는 Object클래스에서 정의되서 모든 객체에서 호출이 가능함. 동기화 블록 내에서만 사용가능. 쓰레드가 wait()을 호출하면 그때까지 걸어 놓은 lock을 풀고 대기실에 들어가기 됨. notify()는 객체의 wating pool에 있는 쓰레드 중 하나만 깨움. wait(), notify(), notifyAll() Object에 정의 되어있다. 동기화 블록(synchronized)내에서만 사용할 수 있다. 보다 효율적인 동기화를 가능하게 한다. 12345678910111213141516class Account{ int balance =1000; public synchronized void withdraw (int money){ if(balance&gt;=money){ try{ wait(); } catch(Exception e){} balance -=money; } }//withdraw}public synchronized void desposit(int money){ balance += money; notify();}","link":"/2019/05/13/tec/java/2019-05-08-java11/"}],"tags":[{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"tec","slug":"tec","link":"/tags/tec/"},{"name":"jekyll","slug":"jekyll","link":"/tags/jekyll/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"disque","slug":"disque","link":"/tags/disque/"},{"name":"java의 정석","slug":"java의-정석","link":"/tags/java의-정석/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"여행","slug":"여행","link":"/tags/여행/"},{"name":"유럽","slug":"유럽","link":"/tags/유럽/"},{"name":"아이슬란드","slug":"아이슬란드","link":"/tags/아이슬란드/"},{"name":"오로라","slug":"오로라","link":"/tags/오로라/"},{"name":"무지개","slug":"무지개","link":"/tags/무지개/"},{"name":"골든서클","slug":"골든서클","link":"/tags/골든서클/"},{"name":"폭포","slug":"폭포","link":"/tags/폭포/"},{"name":"해변","slug":"해변","link":"/tags/해변/"},{"name":"숙소","slug":"숙소","link":"/tags/숙소/"},{"name":"눈","slug":"눈","link":"/tags/눈/"},{"name":"빙하","slug":"빙하","link":"/tags/빙하/"},{"name":"java","slug":"java","link":"/tags/java/"}],"categories":[{"name":"tec","slug":"tec","link":"/categories/tec/"},{"name":"blog","slug":"tec/blog","link":"/categories/tec/blog/"},{"name":"java","slug":"tec/java","link":"/categories/tec/java/"},{"name":"sql","slug":"tec/sql","link":"/categories/tec/sql/"},{"name":"trip","slug":"trip","link":"/categories/trip/"},{"name":"island","slug":"trip/island","link":"/categories/trip/island/"}]}